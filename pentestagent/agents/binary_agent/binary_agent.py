"""BinaryAnalystAgent - main binary analysis agent."""

import os
from typing import TYPE_CHECKING, Any, Dict, List, Optional

from ..base_agent import BaseAgent
from ..prompts import binary_agent

if TYPE_CHECKING:
    from ...knowledge import RAGEngine
    from ...llm import LLM
    from ...runtime import Runtime
    from ...tools import Tool


class BinaryAnalystAgent(BaseAgent):
    """Binary analysis agent powered by IDA Pro.

    This agent specializes in analyzing compiled binaries to identify
    security vulnerabilities such as buffer overflows, format string
    vulnerabilities, and other common issues.
    """

    def __init__(
        self,
        llm: "LLM",
        tools: List["Tool"],
        runtime: "Runtime",
        binary_path: str,
        rag_engine: Optional["RAGEngine"] = None,
        **kwargs,
    ):
        """Initialize the BinaryAnalystAgent.

        Args:
            llm: The LLM instance for generating responses
            tools: List of tools available to the agent
            runtime: The runtime environment for tool execution
            binary_path: Path to the binary file to analyze
            rag_engine: Optional RAG engine for vulnerability pattern knowledge
            **kwargs: Additional arguments passed to BaseAgent
        """
        super().__init__(llm, tools, runtime, **kwargs)
        self.binary_path = os.path.abspath(binary_path)
        self.rag_engine = rag_engine
        self.binary_info: Optional[Dict[str, Any]] = None

    def set_binary_info(self, info: Dict[str, Any]):
        """Set binary metadata from IDA analysis.

        Args:
            info: Dictionary with binary metadata (file_type, bits, entry_point, etc.)
        """
        self.binary_info = info

    def get_system_prompt(self, mode: str = "agent") -> str:
        """Generate system prompt with binary analysis context.

        Args:
            mode: 'agent' for autonomous mode (default)
        """
        # Get RAG context if available
        rag_context = ""
        if self.rag_engine and self.conversation_history:
            last_msg = self.conversation_history[-1].content
            # Ensure content is a string (could be list for multimodal)
            if isinstance(last_msg, list):
                last_msg = " ".join(
                    str(part.get("text", ""))
                    for part in last_msg
                    if isinstance(part, dict)
                )
            if last_msg:
                relevant = self.rag_engine.search(last_msg)
                if relevant:
                    rag_context = "\n\n".join(relevant)

        # Get saved notes if available
        notes_context = ""
        try:
            from ...tools.notes import get_all_notes_sync

            notes = get_all_notes_sync()
            if notes:
                # Group by category
                grouped = {}
                for key, data in notes.items():
                    if isinstance(data, str):
                        cat = "info"
                        content = data
                    else:
                        cat = data.get("category", "info")
                        content = data.get("content", "")

                    # Truncate long notes
                    if len(content) > 200:
                        content = content[:197] + "..."

                    if cat not in grouped:
                        grouped[cat] = []
                    grouped[cat].append(f"- {key}: {content}")

                # Format output
                sections = []
                order = ["vulnerability", "finding", "artifact", "info"]

                for cat in order:
                    if cat in grouped:
                        header = cat.title() + "s"
                        if cat == "info":
                            header = "General Information"
                        sections.append(f"## {header}")
                        sections.append("\n".join(grouped[cat]))

                for cat in sorted(grouped.keys()):
                    if cat not in order:
                        sections.append(f"## {cat.title()}")
                        sections.append("\n".join(grouped[cat]))

                notes_context = "\n\n".join(sections)
        except Exception:
            pass

        # Get environment info from runtime
        env = self.runtime.environment

        return binary_agent.render(
            binary_path=self.binary_path,
            binary_info=self.binary_info,
            environment=env,
            rag_context=rag_context,
            notes_context=notes_context,
            tools=self.tools,
            plan=self._task_plan if mode == "agent" else None,
        )

    def set_binary(self, binary_path: str):
        """Set or update the binary to analyze.

        Args:
            binary_path: Path to the binary file
        """
        self.binary_path = os.path.abspath(binary_path)
        self.binary_info = None  # Reset info for new binary

    async def load_binary(self) -> Dict[str, Any]:
        """Load the binary into IDA Pro using the load_binary tool.

        Returns:
            Dictionary with binary metadata or error information
        """
        # Find the load_binary tool
        load_tool = None
        for tool in self.tools:
            if "load_binary" in tool.name:
                load_tool = tool
                break

        if not load_tool:
            return {"error": "load_binary tool not found", "success": False}

        # Execute the tool
        try:
            result = await load_tool.execute(
                {"file_path": self.binary_path},
                self.runtime
            )
            # Parse result if it's JSON
            if isinstance(result, str):
                import json
                try:
                    result = json.loads(result)
                except json.JSONDecodeError:
                    pass

            if isinstance(result, dict) and result.get("success"):
                self.binary_info = result.get("data", {})
                return result
            return result
        except Exception as e:
            return {"error": str(e), "success": False}
