"""BinaryAnalystAgent - main binary analysis agent."""

import json
import logging
import os
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple

from ..base_agent import BaseAgent
from ..prompts import binary_agent

if TYPE_CHECKING:
    from ...knowledge import RAGEngine
    from ...llm import LLM
    from ...runtime import Runtime
    from ...tools import Tool

# Configure logging for BinaryAnalystAgent
logger = logging.getLogger("pentestagent.binary_agent")

# Required Ghidra MCP tools for binary analysis
# These must be available for the agent to function properly
REQUIRED_GHIDRA_TOOLS = [
    "import_binary",         # Import binary into Ghidra
    "decompile_function",    # Decompile a function
    "search_strings",        # Search strings
    "list_cross_references", # Cross-references
]


class GhidraToolsNotAvailableError(Exception):
    """Raised when required Ghidra MCP tools are not available."""
    pass


class BinaryNotLoadedError(Exception):
    """Raised when binary analysis is attempted without loading the binary first."""
    pass


class BinaryAnalystAgent(BaseAgent):
    """Binary analysis agent powered by Ghidra.

    This agent specializes in analyzing compiled binaries to identify
    security vulnerabilities such as buffer overflows, format string
    vulnerabilities, and other common issues.

    IMPORTANT: This agent requires Ghidra MCP tools to be connected.
    It will fail fast if required tools are not available.
    """

    def __init__(
        self,
        llm: "LLM",
        tools: List["Tool"],
        runtime: "Runtime",
        binary_path: str,
        rag_engine: Optional["RAGEngine"] = None,
        offline_mode: bool = False,
        **kwargs,
    ):
        """Initialize the BinaryAnalystAgent.

        Args:
            llm: The LLM instance for generating responses
            tools: List of tools available to the agent
            runtime: The runtime environment for tool execution
            binary_path: Path to the binary file to analyze
            rag_engine: Optional RAG engine for vulnerability pattern knowledge
            offline_mode: If True, allow running without Ghidra tools (limited analysis)
            **kwargs: Additional arguments passed to BaseAgent
        """
        super().__init__(llm, tools, runtime, **kwargs)
        self.binary_path = os.path.abspath(binary_path)
        self.rag_engine = rag_engine
        self.binary_info: Optional[Dict[str, Any]] = None
        self.offline_mode = offline_mode
        self._binary_loaded = False
        self._ghidra_tools_verified = False

        # Log initialization
        logger.info(f"[BINARY_AGENT] Initialized for binary: {self.binary_path}")
        logger.info(f"[BINARY_AGENT] Offline mode: {offline_mode}")

    def verify_ghidra_tools(self) -> Tuple[bool, List[str], List[str]]:
        """Verify that required Ghidra MCP tools are available.

        Returns:
            Tuple of (all_available, found_tools, missing_tools)
        """
        found_tools = []
        missing_tools = []

        # Get all tool names (Ghidra tools are prefixed with mcp_ghidra-local_ or similar)
        tool_names = [t.name for t in self.tools]

        logger.info(f"[BINARY_AGENT] Verifying Ghidra tools. Available tools: {len(tool_names)}")

        for required in REQUIRED_GHIDRA_TOOLS:
            # Look for tool with matching name (could be mcp_ghidra-local_import_binary etc)
            found = False
            for name in tool_names:
                if required in name.lower():
                    found = True
                    found_tools.append(name)
                    break
            if not found:
                missing_tools.append(required)

        all_available = len(missing_tools) == 0

        if all_available:
            logger.info(f"[BINARY_AGENT] All required Ghidra tools verified: {found_tools}")
        else:
            logger.warning(f"[BINARY_AGENT] Missing Ghidra tools: {missing_tools}")
            logger.info(f"[BINARY_AGENT] Found Ghidra tools: {found_tools}")

        self._ghidra_tools_verified = all_available
        return all_available, found_tools, missing_tools

    def get_ghidra_tool(self, tool_name: str) -> Optional["Tool"]:
        """Get a Ghidra tool by its base name (e.g., 'import_binary').

        Args:
            tool_name: The base name of the tool (without mcp prefix)

        Returns:
            The Tool instance or None if not found
        """
        for tool in self.tools:
            if tool_name in tool.name.lower():
                return tool
        return None

    async def bootstrap(self) -> Dict[str, Any]:
        """Bootstrap the agent by verifying tools and loading the binary.

        This MUST be called before running the agent loop.
        It ensures deterministic behavior by:
        1. Verifying Ghidra tools are available
        2. Importing the binary into Ghidra automatically

        Returns:
            Dict with bootstrap status and binary info

        Raises:
            GhidraToolsNotAvailableError: If required Ghidra tools are missing and not in offline_mode
            FileNotFoundError: If the binary file doesn't exist
        """
        logger.info("[BINARY_AGENT] === BOOTSTRAP PHASE START ===")

        # 1. Verify binary file exists
        if not os.path.isfile(self.binary_path):
            error_msg = f"Binary file not found: {self.binary_path}"
            logger.error(f"[BINARY_AGENT] {error_msg}")
            raise FileNotFoundError(error_msg)

        logger.info(f"[BINARY_AGENT] Binary file verified: {self.binary_path}")

        # 2. Verify Ghidra tools
        all_available, found_tools, missing_tools = self.verify_ghidra_tools()

        if not all_available:
            if self.offline_mode:
                logger.warning(
                    "[BINARY_AGENT] Running in OFFLINE MODE - Ghidra tools not available. "
                    "Analysis will be limited to non-Ghidra methods."
                )
                return {
                    "success": True,
                    "mode": "offline",
                    "message": "Running in offline mode without Ghidra tools",
                    "missing_tools": missing_tools,
                }
            else:
                error_msg = (
                    f"Ghidra MCP tools not available. Missing: {missing_tools}. "
                    "Ensure Ghidra MCP server is running and connected. "
                    "Set LAUNCH_GHIDRA=1 in .env or start the server manually. "
                    "Use offline_mode=True to run without Ghidra (limited analysis)."
                )
                logger.error(f"[BINARY_AGENT] {error_msg}")
                raise GhidraToolsNotAvailableError(error_msg)

        # 3. Auto-import binary into Ghidra
        logger.info(f"[BINARY_AGENT] Importing binary into Ghidra: {self.binary_path}")
        load_result = await self.load_binary()

        if isinstance(load_result, dict) and load_result.get("success"):
            self._binary_loaded = True
            logger.info(f"[BINARY_AGENT] Binary imported successfully")
            if self.binary_info:
                logger.info(f"[BINARY_AGENT] Binary info: {json.dumps(self.binary_info, indent=2)}")
        else:
            error_detail = load_result.get("error", "Unknown error") if isinstance(load_result, dict) else str(load_result)
            logger.error(f"[BINARY_AGENT] Failed to import binary: {error_detail}")

            if not self.offline_mode:
                raise BinaryNotLoadedError(
                    f"Failed to import binary into Ghidra: {error_detail}. "
                    "Check Ghidra installation and paths."
                )

        logger.info("[BINARY_AGENT] === BOOTSTRAP PHASE COMPLETE ===")

        return {
            "success": True,
            "mode": "ghidra" if self._binary_loaded else "offline",
            "binary_path": self.binary_path,
            "binary_info": self.binary_info,
            "ghidra_tools": found_tools,
        }

    def set_binary_info(self, info: Dict[str, Any]):
        """Set binary metadata from Ghidra analysis.

        Args:
            info: Dictionary with binary metadata (file_type, bits, entry_point, etc.)
        """
        self.binary_info = info

    def get_system_prompt(self, mode: str = "agent") -> str:
        """Generate system prompt with binary analysis context.

        Args:
            mode: 'agent' for autonomous mode (default)
        """
        # Get RAG context if available
        rag_context = ""
        if self.rag_engine and self.conversation_history:
            last_msg = self.conversation_history[-1].content
            # Ensure content is a string (could be list for multimodal)
            if isinstance(last_msg, list):
                last_msg = " ".join(
                    str(part.get("text", ""))
                    for part in last_msg
                    if isinstance(part, dict)
                )
            if last_msg:
                relevant = self.rag_engine.search(last_msg)
                if relevant:
                    rag_context = "\n\n".join(relevant)

        # Get saved notes if available
        notes_context = ""
        try:
            from ...tools.notes import get_all_notes_sync

            notes = get_all_notes_sync()
            if notes:
                # Group by category
                grouped = {}
                for key, data in notes.items():
                    if isinstance(data, str):
                        cat = "info"
                        content = data
                    else:
                        cat = data.get("category", "info")
                        content = data.get("content", "")

                    # Truncate long notes
                    if len(content) > 200:
                        content = content[:197] + "..."

                    if cat not in grouped:
                        grouped[cat] = []
                    grouped[cat].append(f"- {key}: {content}")

                # Format output
                sections = []
                order = ["vulnerability", "finding", "artifact", "info"]

                for cat in order:
                    if cat in grouped:
                        header = cat.title() + "s"
                        if cat == "info":
                            header = "General Information"
                        sections.append(f"## {header}")
                        sections.append("\n".join(grouped[cat]))

                for cat in sorted(grouped.keys()):
                    if cat not in order:
                        sections.append(f"## {cat.title()}")
                        sections.append("\n".join(grouped[cat]))

                notes_context = "\n\n".join(sections)
        except Exception:
            pass

        # Get environment info from runtime
        env = self.runtime.environment

        return binary_agent.render(
            binary_path=self.binary_path,
            binary_info=self.binary_info,
            environment=env,
            rag_context=rag_context,
            notes_context=notes_context,
            tools=self.tools,
            plan=self._task_plan if mode == "agent" else None,
        )

    def set_binary(self, binary_path: str):
        """Set or update the binary to analyze.

        Args:
            binary_path: Path to the binary file
        """
        self.binary_path = os.path.abspath(binary_path)
        self.binary_info = None  # Reset info for new binary

    async def load_binary(self) -> Dict[str, Any]:
        """Import the binary into Ghidra using the import_binary tool.

        This is called automatically by bootstrap() and should not need
        to be called manually.

        Returns:
            Dictionary with binary metadata or error information
        """
        logger.info(f"[BINARY_AGENT] load_binary() called for: {self.binary_path}")

        # Find the import_binary tool
        load_tool = self.get_ghidra_tool("import_binary")

        if not load_tool:
            error_msg = "import_binary tool not found in available tools"
            logger.error(f"[BINARY_AGENT] {error_msg}")
            return {"error": error_msg, "success": False}

        logger.info(f"[BINARY_AGENT] Using tool: {load_tool.name}")

        # Execute the tool
        try:
            result = await load_tool.execute(
                {"binary_path": self.binary_path},
                self.runtime
            )

            # Parse result if it's JSON string
            if isinstance(result, str):
                try:
                    result = json.loads(result)
                except json.JSONDecodeError:
                    # Not JSON, treat as plain text result
                    logger.warning(f"[BINARY_AGENT] import_binary returned non-JSON: {result[:200]}")
                    pass

            if isinstance(result, dict) and result.get("success"):
                self.binary_info = result.get("data", {})
                self._binary_loaded = True
                logger.info(f"[BINARY_AGENT] import_binary SUCCESS")
                return result
            else:
                error_detail = result.get("error", "Unknown error") if isinstance(result, dict) else str(result)
                logger.error(f"[BINARY_AGENT] import_binary FAILED: {error_detail}")
                return result if isinstance(result, dict) else {"error": str(result), "success": False}

        except Exception as e:
            logger.exception(f"[BINARY_AGENT] import_binary EXCEPTION: {e}")
            return {"error": str(e), "success": False}
