"""Main entry point for BinAgent (PentestAgent)."""

import argparse
import asyncio
import os

from ..config.constants import AGENT_MAX_ITERATIONS, DEFAULT_MODEL


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="BinAgent - AI-driven Security Analysis & CTF Solving",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Binary vulnerability analysis (uses Ghidra when available)
  binagent analyze ./binary
  binagent analyze ./binary --task "Find buffer overflow vulnerabilities"
  binagent analyze ./binary --offline    # Without Ghidra (reduced fidelity)

  # CTF solving (flags, reverse engineering, network)
  binagent solve "nc example.com 12345"
  binagent solve --file ./challenge.apk
  binagent solve --file ./binary --desc "Buffer overflow CTF"
  binagent solve --connect example.com:12345

  # Utility commands
  binagent tools list
  binagent mcp list
  binagent tui                           # Interactive mode
  binagent run -t localhost --task "scan"

Architecture:
  BinAgent uses an LLM-driven agent loop: Plan → Act → Observe → Re-plan
  Planning is MANDATORY: 3-7 validated steps before any tool calls.

Output (runs/<run-id>/):
  plan.json        - Validated execution plan
  tool_log.json    - Chronological tool calls
  evidence.json    - Evidence trail
  outcome.json     - Final results (flags/findings)
  transcript.txt   - Full execution log
        """,
    )

    parser.add_argument("--version", action="version", version="BinAgent 0.3.0")

    # Subcommands
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Common arguments for runtime modes
    runtime_parent = argparse.ArgumentParser(add_help=False)
    runtime_parent.add_argument("--target", "-t", help="Target (IP, hostname, or URL)")
    runtime_parent.add_argument(
        "--model",
        "-m",
        default=DEFAULT_MODEL,
        help="LLM model (set PENTESTAGENT_MODEL in .env)",
    )
    runtime_parent.add_argument(
        "--docker",
        "-d",
        action="store_true",
        help="Run tools inside Docker container (requires Docker)",
    )
    runtime_parent.add_argument(
        "--playbook",
        "-p",
        help="Playbook to execute (e.g., thp3_web)",
    )

    # TUI subcommand
    subparsers.add_parser(
        "tui", parents=[runtime_parent], help="Launch TUI (Interactive Mode)"
    )

    # Run subcommand (Headless)
    run_parser = subparsers.add_parser(
        "run", parents=[runtime_parent], help="Run in headless mode"
    )
    run_parser.add_argument("task", nargs="*", help="Task to run")
    run_parser.add_argument(
        "--report",
        "-r",
        nargs="?",
        const="auto",
        help=(
            "Generate report. "
            "If used without value, auto-generates path under loot/reports/. "
            "If omitted, no report is generated."
        ),
    )
    run_parser.add_argument(
        "--max-loops",
        type=int,
        default=AGENT_MAX_ITERATIONS,
        help=f"Max agent loops before stopping (default: {AGENT_MAX_ITERATIONS})",
    )

    # ==========================================================================
    # ANALYZE subcommand - vulnerability detection / RE analysis
    # ==========================================================================
    analyze_parser = subparsers.add_parser(
        "analyze",
        help="Analyze binary/file for vulnerabilities (uses Ghidra when available)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  binagent analyze ./binary
  binagent analyze ./binary --task "Focus on format string vulnerabilities"
  binagent analyze ./app.apk
  binagent analyze ./binary --offline    # Without Ghidra MCP

Mode: ANALYZE
  - Goal: Produce security analysis report with CWE labels and evidence
  - Identifies vulnerability classes with file:line or func:offset evidence
  - Uses Ghidra MCP tools when available for deep static analysis
  - Falls back to strings/objdump/readelf when Ghidra unavailable

Output (runs/<run-id>/):
  plan.json      - Analysis plan (3-7 steps)
  tool_log.json  - All tool calls with timestamps
  evidence.json  - Evidence trail (functions, patterns)
  outcome.json   - Findings with CWE labels
  transcript.txt - Full agent execution log
        """,
    )
    analyze_parser.add_argument(
        "target_file", help="Path to the file to analyze (binary, APK, etc.)"
    )
    analyze_parser.add_argument(
        "--model",
        "-m",
        default=DEFAULT_MODEL,
        help="LLM model (set PENTESTAGENT_MODEL in .env)",
    )
    analyze_parser.add_argument(
        "--task",
        "-t",
        default="Analyze this file for security vulnerabilities. Focus on buffer overflows, format string bugs, and other memory corruption issues.",
        help="Specific analysis task/focus",
    )
    analyze_parser.add_argument(
        "--run-id",
        help="Custom run ID (default: timestamp-based)",
    )
    analyze_parser.add_argument(
        "--flag-regex",
        default=r"picoCTF\{[^}]+\}|flag\{[^}]+\}|CTF\{[^}]+\}",
        help="Regex for flags (still extracted if found during analysis)",
    )
    analyze_parser.add_argument(
        "--max-loops",
        type=int,
        default=AGENT_MAX_ITERATIONS,
        help=f"Max agent loops before stopping (default: {AGENT_MAX_ITERATIONS})",
    )
    analyze_parser.add_argument(
        "--ghidra-path",
        help="Path to Ghidra installation directory",
    )
    analyze_parser.add_argument(
        "--offline",
        action="store_true",
        help="Run without Ghidra MCP tools (reduced fidelity mode)",
    )

    # ==========================================================================
    # SOLVE subcommand - CTF-style flag finding
    # ==========================================================================
    solve_parser = subparsers.add_parser(
        "solve",
        help="Solve CTF challenges (files, network, reverse engineering)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Network/netcat challenges
  binagent solve "nc example.com 12345"
  binagent solve --connect example.com:12345 --desc "SQL injection"

  # File-based challenges (binary, APK, archive)
  binagent solve --file ./challenge.apk
  binagent solve --file ./binary --desc "Buffer overflow CTF"

  # Combined
  binagent solve --file ./exploit.py --connect target:1337

Mode: SOLVE
  - Goal: Obtain the flag and provide evidence trail
  - Treats description as puzzle specification
  - Reverse engineers files (binary, APK, archive)
  - Interacts with network services (netcat)
  - Decodes/transforms content (base64, hex, XOR, etc.)

Output (runs/<run-id>/):
  plan.json      - Solving strategy (3-7 steps)
  tool_log.json  - All tool calls with timestamps
  evidence.json  - Evidence chain to flag
  outcome.json   - Found flags
  transcript.txt - Full agent execution log
        """,
    )
    solve_parser.add_argument(
        "description",
        nargs="*",
        help="Challenge description (can include 'nc host port')",
    )
    solve_parser.add_argument(
        "--file", "-f",
        help="Challenge file (APK, binary, archive, etc.)",
    )
    solve_parser.add_argument(
        "--connect", "-c",
        help="Target host:port (e.g., example.com:12345)",
    )
    solve_parser.add_argument(
        "--desc", "-d",
        help="Additional description text",
    )
    solve_parser.add_argument(
        "--model", "-m",
        default=DEFAULT_MODEL,
        help="LLM model (set PENTESTAGENT_MODEL in .env)",
    )
    solve_parser.add_argument(
        "--run-id",
        help="Custom run ID (default: timestamp-based)",
    )
    solve_parser.add_argument(
        "--flag-regex",
        default=r"picoCTF\{[^}]+\}|flag\{[^}]+\}|CTF\{[^}]+\}",
        help="Regex to match flags",
    )
    solve_parser.add_argument(
        "--max-loops",
        type=int,
        default=AGENT_MAX_ITERATIONS,
        help=f"Max agent loops before stopping (default: {AGENT_MAX_ITERATIONS})",
    )
    solve_parser.add_argument(
        "--offline",
        action="store_true",
        help="Run without Ghidra MCP tools",
    )

    # ==========================================================================
    # Tools subcommand
    # ==========================================================================
    tools_parser = subparsers.add_parser("tools", help="Manage tools")
    tools_subparsers = tools_parser.add_subparsers(
        dest="tools_command", help="Tool commands"
    )

    # tools list
    tools_subparsers.add_parser("list", help="List all available tools")

    # tools info
    tools_info = tools_subparsers.add_parser("info", help="Show tool details")
    tools_info.add_argument("name", help="Tool name")

    # tools env
    tools_subparsers.add_parser("env", help="Show detected CLI tools in environment")

    # ==========================================================================
    # MCP subcommand
    # ==========================================================================
    mcp_parser = subparsers.add_parser("mcp", help="Manage MCP servers")
    mcp_subparsers = mcp_parser.add_subparsers(dest="mcp_command", help="MCP commands")

    # mcp list
    mcp_subparsers.add_parser("list", help="List configured MCP servers")

    # mcp add
    mcp_add = mcp_subparsers.add_parser("add", help="Add an MCP server")
    mcp_add.add_argument("name", help="Server name")
    mcp_add.add_argument("command", help="Command to run (e.g., npx)")
    mcp_add.add_argument("args", nargs="*", help="Command arguments")
    mcp_add.add_argument("--description", default="", help="Server description")

    # mcp remove
    mcp_remove = mcp_subparsers.add_parser("remove", help="Remove an MCP server")
    mcp_remove.add_argument("name", help="Server name to remove")

    # mcp disable
    mcp_disable = mcp_subparsers.add_parser(
        "disable", help="Disable an MCP server (update config)"
    )
    mcp_disable.add_argument("name", help="Server name to disable")

    # mcp enable
    mcp_enable = mcp_subparsers.add_parser(
        "enable", help="Enable an MCP server (update config)"
    )
    mcp_enable.add_argument("name", help="Server name to enable")

    # mcp test
    mcp_test = mcp_subparsers.add_parser("test", help="Test MCP server connection")
    mcp_test.add_argument("name", help="Server name to test")

    return parser, parser.parse_args()


def handle_tools_command(args: argparse.Namespace):
    """Handle tools subcommand."""
    from rich.console import Console
    from rich.table import Table

    from ..tools import get_all_tools, get_tool

    console = Console()

    if args.tools_command == "list":
        tools = get_all_tools()

        if not tools:
            console.print("[yellow]No tools found[/]")
            return

        table = Table(title="Available Tools")
        table.add_column("Name", style="cyan")
        table.add_column("Category", style="green")
        table.add_column("Description")

        for tool in sorted(tools, key=lambda t: t.name):
            desc = (
                tool.description[:50] + "..."
                if len(tool.description) > 50
                else tool.description
            )
            table.add_row(tool.name, tool.category, desc)

        console.print(table)
        console.print(f"\nTotal: {len(tools)} tools")

    elif args.tools_command == "info":
        tool = get_tool(args.name)
        if not tool:
            console.print(f"[red]Tool not found: {args.name}[/]")
            return

        console.print(f"\n[bold cyan]{tool.name}[/]")
        console.print(f"[dim]Category:[/] {tool.category}")
        console.print(f"\n{tool.description}")

        if tool.schema.properties:
            console.print("\n[bold]Parameters:[/]")
            for name, props in tool.schema.properties.items():
                required = (
                    "required" if name in (tool.schema.required or []) else "optional"
                )
                ptype = props.get("type", "any")
                desc = props.get("description", "")
                console.print(f"  [cyan]{name}[/] ({ptype}, {required}): {desc}")

    elif args.tools_command == "env":
        from ..runtime.runtime import detect_environment

        env = detect_environment()

        console.print("\n[bold]Environment:[/]")
        console.print(f"  OS: {env.os} ({env.os_version})")
        console.print(f"  Architecture: {env.architecture}")
        console.print(f"  Shell: {env.shell}")

        if env.available_tools:
            console.print(
                f"\n[bold]Detected CLI Tools ({len(env.available_tools)}):[/]"
            )

            # Group by category
            by_category = {}
            for tool_info in env.available_tools:
                if tool_info.category not in by_category:
                    by_category[tool_info.category] = []
                by_category[tool_info.category].append(tool_info)

            for category in sorted(by_category.keys()):
                tools_in_cat = by_category[category]
                console.print(f"\n[bold cyan]{category}[/] ({len(tools_in_cat)}):")
                for tool_info in sorted(tools_in_cat, key=lambda t: t.name):
                    console.print(f"  • {tool_info.name}")
        else:
            console.print("\n[yellow]No CLI tools detected[/]")
            console.print(
                "\n[dim]Tip: Install tools like nmap, curl, git to expand capabilities[/]"
            )

    else:
        console.print("[yellow]Use 'binagent tools --help' for commands[/]")


def handle_mcp_command(args: argparse.Namespace):
    """Handle MCP subcommand."""
    from rich.console import Console
    from rich.table import Table

    from ..mcp.manager import MCPManager

    console = Console()
    manager = MCPManager()

    if args.mcp_command == "list":
        servers = manager.list_configured_servers()

        if not servers:
            console.print("[yellow]No MCP servers configured[/]")
            console.print(
                "\nAdd a server with: binagent mcp add <name> <command> <args...>"
            )
            return

        table = Table(title="Configured MCP Servers")
        table.add_column("Name", style="cyan")
        table.add_column("Command", style="green")
        table.add_column("Args")
        table.add_column("Connected", style="yellow")

        for server in servers:
            args_str = " ".join(server["args"][:3])
            if len(server["args"]) > 3:
                args_str += "..."
            connected = "+" if server.get("connected") else "-"
            table.add_row(server["name"], server["command"], args_str, connected)

        console.print(table)
        console.print(f"\nConfig file: {manager.config_path}")

    elif args.mcp_command == "add":
        manager.add_server(
            name=args.name,
            command=args.command,
            args=args.args or [],
            description=args.description,
        )
        console.print(f"[green]Added MCP server: {args.name}[/]")
        console.print(f"  Command: {args.command} {' '.join(args.args or [])}")

    elif args.mcp_command == "remove":
        if manager.remove_server(args.name):
            console.print(f"[yellow]Removed MCP server: {args.name}[/]")
        else:
            console.print(f"[red]Server not found: {args.name}[/]")

    elif args.mcp_command == "disable":
        if manager.set_enabled(args.name, False):
            console.print(f"[yellow]Disabled MCP server in config: {args.name}[/]")
        else:
            console.print(f"[red]Server not found: {args.name}[/]")

    elif args.mcp_command == "enable":
        if manager.set_enabled(args.name, True):
            console.print(f"[green]Enabled MCP server in config: {args.name}[/]")
        else:
            console.print(f"[red]Server not found: {args.name}[/]")

    elif args.mcp_command == "test":
        console.print(f"[bold]Testing MCP server: {args.name}[/]\n")

        async def test_server():
            server = await manager.connect_server(args.name)
            if server and server.connected:
                console.print("[green]+ Connected successfully![/]")
                console.print(f"\n[bold]Available tools ({len(server.tools)}):[/]")
                for tool in server.tools:
                    desc = tool.get("description", "No description")[:60]
                    console.print(f"  [cyan]{tool['name']}[/]: {desc}")
                await manager.disconnect_all()
            else:
                console.print("[red]x Failed to connect[/]")

        asyncio.run(test_server())

    else:
        console.print("[yellow]Use 'binagent mcp --help' for available commands[/]")


def handle_analyze_command(args: argparse.Namespace):
    """
    Handle ANALYZE command using GeneralAgent with AgentMode.ANALYZE.

    Mode: vulnerability detection / RE analysis
    Goal: Produce security analysis report with CWE labels and evidence
    """
    from rich.console import Console
    from rich.panel import Panel
    from rich.text import Text

    from ..agents import GeneralAgent, TaskContext, AgentMode
    from ..tools.general import register_general_tools

    console = Console()

    # Validate file exists
    target_file = args.target_file
    if not os.path.isfile(target_file):
        console.print(f"[red]Error: File not found: {target_file}[/]")
        return

    target_file = os.path.abspath(target_file)

    # Set Ghidra path if provided
    if args.ghidra_path:
        os.environ["GHIDRA_INSTALL_DIR"] = args.ghidra_path

    # Check model
    model = getattr(args, 'model', None) or DEFAULT_MODEL
    if not model:
        console.print("[red]Error: No model configured.[/]")
        console.print("Set PENTESTAGENT_MODEL in .env or use --model flag.")
        return

    # Build task context
    from datetime import datetime
    context = TaskContext(
        mode=AgentMode.ANALYZE,
        description=args.task,
        file_path=target_file,
        flag_regex=args.flag_regex,
        run_id=args.run_id or datetime.now().strftime("%Y%m%d_%H%M%S"),
    )

    # Display startup info
    start_text = Text()
    start_text.append("BINAGENT ANALYZE\n\n", style="bold white")
    start_text.append("File:    ", style="dim")
    start_text.append(f"{target_file}\n", style="cyan")
    start_text.append("Task:    ", style="dim")
    task_preview = args.task[:60] + "..." if len(args.task) > 60 else args.task
    start_text.append(f"{task_preview}\n", style="white")
    start_text.append("Model:   ", style="dim")
    start_text.append(f"{model}\n", style="white")
    if args.offline:
        start_text.append("Ghidra:  ", style="dim")
        start_text.append("DISABLED (offline mode)\n", style="yellow")

    console.print()
    console.print(Panel(start_text, title="[dim]Starting Analysis", border_style="dim"))
    console.print()

    # Run the agent
    async def run_agent():
        from ..llm import LLM
        from ..runtime import LocalRuntime
        from ..tools import get_all_tools
        from ..mcp.manager import MCPManager

        # Create LLM and runtime
        llm = LLM(model=model)
        runtime = LocalRuntime()

        # Register general tools
        register_general_tools()

        # Get all available tools
        tools = list(get_all_tools())

        # Connect MCP servers (unless offline mode)
        mcp_manager = None
        if not args.offline:
            console.print("[dim]Connecting MCP servers...[/]")
            mcp_manager = MCPManager()
            mcp_tools = await mcp_manager.connect_all()
            tools.extend(mcp_tools)
            console.print(f"[dim]MCP tools added: {len(mcp_tools)}[/]")

        console.print(f"[dim]Total tools available: {len(tools)}[/]")
        console.print(f"[dim]LLM-driven agent loop starting...[/]")
        console.print()

        # Create and run agent
        agent = GeneralAgent(
            llm=llm,
            tools=tools,
            runtime=runtime,
            context=context,
            max_iterations=args.max_loops,
        )

        result = await agent.solve()

        # Disconnect MCP
        if mcp_manager:
            await mcp_manager.disconnect_all()

        return result

    try:
        result = asyncio.run(run_agent())
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/]")
        return
    except Exception as e:
        console.print(f"[red]Error: {e}[/]")
        import traceback
        traceback.print_exc()
        return

    # Display results
    console.print()
    console.print("=" * 60)
    if result["success"]:
        console.print("[bold green]ANALYSIS COMPLETE - FINDINGS IDENTIFIED[/]")
    else:
        console.print("[bold yellow]ANALYSIS COMPLETE - NO FINDINGS[/]")
    console.print("=" * 60)

    console.print(f"Run ID:       {result['run_id']}")
    console.print(f"Elapsed:      {result['elapsed_seconds']:.2f}s")
    console.print(f"Ghidra:       {'Available' if result.get('ghidra_available') else 'Not available'}")
    console.print(f"Fallback:     {'Yes' if result.get('used_fallback_plan') else 'No'}")

    if result.get("findings"):
        console.print(f"\n[bold]Findings ({len(result['findings'])}):[/]")
        for f in result["findings"][:10]:
            cwe = f.get("cwe", "Unknown")
            ctx = f.get("context", "")[:80]
            console.print(f"  [yellow]{cwe}[/]: {ctx}...")

    if result.get("flags"):
        console.print(f"\n[bold green]Flags found ({len(result['flags'])}):[/]")
        for flag in result["flags"]:
            console.print(f"  [bold green]{flag}[/]")

    console.print(f"\n[dim]Artifacts: {result['out_dir']}/[/]")
    console.print(f"  plan.json      - Analysis plan")
    console.print(f"  tool_log.json  - Tool call history")
    console.print(f"  evidence.json  - Evidence trail")
    console.print(f"  outcome.json   - Findings with CWE")
    console.print(f"  transcript.txt - Full execution log")
    console.print("=" * 60)


def handle_solve_command(args: argparse.Namespace):
    """
    Handle SOLVE command using GeneralAgent with AgentMode.SOLVE.

    Mode: CTF-style flag finding
    Goal: Obtain the flag and provide evidence trail
    """
    from rich.console import Console
    from rich.panel import Panel
    from rich.text import Text

    from ..agents import GeneralAgent, TaskContext, AgentMode
    from ..ctf import parse_nc_target, parse_connect_string
    from ..tools.general import register_general_tools

    console = Console()

    # Collect description from various sources
    description_parts = []
    if args.description:
        description_parts.append(" ".join(args.description))
    if args.desc:
        description_parts.append(args.desc)
    full_description = " ".join(description_parts)

    # Parse network target
    host = None
    port = None

    # Try --connect first
    if args.connect:
        parsed = parse_connect_string(args.connect)
        if parsed:
            host = parsed.host
            port = parsed.port
        else:
            console.print(f"[red]Error: Invalid --connect format: {args.connect}[/]")
            console.print("Expected format: host:port")
            return

    # Try to extract from description if not provided
    if not host and full_description:
        parsed = parse_nc_target(full_description)
        if parsed:
            host = parsed.host
            port = parsed.port
            console.print(f"[dim]Extracted target: {host}:{port}[/]")

    # Validate file if provided
    file_path = None
    if args.file:
        if not os.path.isfile(args.file):
            console.print(f"[red]Error: File not found: {args.file}[/]")
            return
        file_path = os.path.abspath(args.file)

    # Need at least description, file, or host:port
    if not full_description and not file_path and not (host and port):
        console.print("[red]Error: Provide description, --file, or --connect[/]")
        console.print("\nExamples:")
        console.print('  binagent solve "nc example.com 12345"')
        console.print("  binagent solve --file ./challenge.apk")
        console.print("  binagent solve --connect example.com:12345")
        return

    # Check model
    model = getattr(args, 'model', None) or DEFAULT_MODEL
    if not model:
        console.print("[red]Error: No model configured.[/]")
        console.print("Set PENTESTAGENT_MODEL in .env or use --model flag.")
        return

    # Build task context
    from datetime import datetime
    context = TaskContext(
        mode=AgentMode.SOLVE,
        description=full_description,
        file_path=file_path,
        host=host,
        port=port,
        flag_regex=args.flag_regex,
        run_id=args.run_id or datetime.now().strftime("%Y%m%d_%H%M%S"),
    )

    # Display startup info
    start_text = Text()
    start_text.append("BINAGENT SOLVE\n\n", style="bold white")
    if full_description:
        desc_preview = full_description[:80] + "..." if len(full_description) > 80 else full_description
        start_text.append("Description: ", style="dim")
        start_text.append(f"{desc_preview}\n", style="white")
    if file_path:
        start_text.append("File:        ", style="dim")
        start_text.append(f"{file_path}\n", style="cyan")
    if host and port:
        start_text.append("Target:      ", style="dim")
        start_text.append(f"{host}:{port}\n", style="cyan")
    start_text.append("Model:       ", style="dim")
    start_text.append(f"{model}\n", style="white")

    console.print()
    console.print(Panel(start_text, title="[dim]Starting Solver", border_style="dim"))
    console.print()

    # Run the agent
    async def run_agent():
        from ..llm import LLM
        from ..runtime import LocalRuntime
        from ..tools import get_all_tools
        from ..mcp.manager import MCPManager

        # Create LLM and runtime
        llm = LLM(model=model)
        runtime = LocalRuntime()

        # Register general tools
        register_general_tools()

        # Get all available tools
        tools = list(get_all_tools())

        # Connect MCP servers (unless offline mode)
        offline = getattr(args, 'offline', False)
        mcp_manager = None
        if not offline:
            console.print("[dim]Connecting MCP servers...[/]")
            mcp_manager = MCPManager()
            mcp_tools = await mcp_manager.connect_all()
            tools.extend(mcp_tools)
            console.print(f"[dim]MCP tools added: {len(mcp_tools)}[/]")

        console.print(f"[dim]Total tools available: {len(tools)}[/]")
        console.print(f"[dim]LLM-driven agent loop starting...[/]")
        console.print()

        # Create and run agent
        agent = GeneralAgent(
            llm=llm,
            tools=tools,
            runtime=runtime,
            context=context,
            max_iterations=args.max_loops,
        )

        result = await agent.solve()

        # Disconnect MCP
        if mcp_manager:
            await mcp_manager.disconnect_all()

        return result

    try:
        result = asyncio.run(run_agent())
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/]")
        return
    except Exception as e:
        console.print(f"[red]Error: {e}[/]")
        import traceback
        traceback.print_exc()
        return

    # Display results
    console.print()
    console.print("=" * 60)
    if result["success"]:
        console.print("[bold green]SUCCESS - FLAG FOUND[/]")
    else:
        console.print("[bold yellow]NO FLAG FOUND[/]")
    console.print("=" * 60)

    console.print(f"Run ID:       {result['run_id']}")
    console.print(f"Elapsed:      {result['elapsed_seconds']:.2f}s")
    console.print(f"Ghidra:       {'Available' if result.get('ghidra_available') else 'Not available'}")
    console.print(f"Fallback:     {'Yes' if result.get('used_fallback_plan') else 'No'}")

    if result.get("flags"):
        console.print(f"\n[bold green]Flags ({len(result['flags'])}):[/]")
        for flag in result["flags"]:
            console.print(f"  [bold green]{flag}[/]")

    if result.get("findings"):
        console.print(f"\n[bold]Findings ({len(result['findings'])}):[/]")
        for f in result["findings"][:5]:
            console.print(f"  - {f}")

    if not result.get("flags") and not result.get("findings"):
        console.print("\n[yellow]No flags or findings.[/]")

    console.print(f"\n[dim]Artifacts: {result['out_dir']}/[/]")
    console.print(f"  plan.json      - Solving strategy")
    console.print(f"  tool_log.json  - Tool call history")
    console.print(f"  evidence.json  - Evidence chain")
    console.print(f"  outcome.json   - Found flags")
    console.print(f"  transcript.txt - Full execution log")
    console.print("=" * 60)


def main():
    """Main entry point."""
    from .cli import run_cli
    from .tui import run_tui

    parser, args = parse_arguments()

    # Handle subcommands
    if args.command == "tools":
        handle_tools_command(args)
        return

    if args.command == "mcp":
        handle_mcp_command(args)
        return

    if args.command == "analyze":
        handle_analyze_command(args)
        return

    if args.command == "solve":
        handle_solve_command(args)
        return

    if args.command == "run":
        # Check model configuration
        if not args.model:
            print("Error: No model configured.")
            print("Set PENTESTAGENT_MODEL in .env file or use --model flag.")
            print(
                "Example: PENTESTAGENT_MODEL=gpt-5 or PENTESTAGENT_MODEL=claude-sonnet-4-20250514"
            )
            return

        if not args.target:
            print("Error: --target is required for run mode")
            return

        # Handle playbook or task
        task_description = ""
        mode = "agent"
        if args.playbook:
            from ..playbooks import get_playbook

            try:
                playbook = get_playbook(args.playbook)
                task_description = playbook.get_task()
                mode = getattr(playbook, "mode", "agent")

                # Use playbook's max_loops if defined
                if hasattr(playbook, "max_loops"):
                    args.max_loops = playbook.max_loops

                print(f"Loaded playbook: {playbook.name}")
                print(f"Description: {playbook.description}")
                print(f"Mode: {mode}")
            except ValueError as e:
                print(f"Error: {e}")
                return
        elif args.task:
            task_description = " ".join(args.task)
        else:
            print("Error: Either task (positional) or --playbook is required")
            return

        try:
            asyncio.run(
                run_cli(
                    target=args.target,
                    model=args.model,
                    task=task_description,
                    report=args.report,
                    max_loops=args.max_loops,
                    use_docker=args.docker,
                    mode=mode,
                )
            )
        except KeyboardInterrupt:
            print("\n[!] Interrupted by user.")
        return

    if args.command == "tui":
        # Check model configuration
        if not args.model:
            print("Error: No model configured.")
            print("Set PENTESTAGENT_MODEL in .env file or use --model flag.")
            print(
                "Example: PENTESTAGENT_MODEL=gpt-5 or PENTESTAGENT_MODEL=claude-sonnet-4-20250514"
            )
            return

        run_tui(target=args.target, model=args.model, use_docker=args.docker)
        return

    # If no command provided, default to TUI
    if args.command is None:
        # Ensure a default model is configured; provide a friendly error if not
        if not DEFAULT_MODEL:
            print("Error: No default model configured (PENTESTAGENT_MODEL).")
            print("Set PENTESTAGENT_MODEL in .env file or pass --model on the command line.")
            print(
                "Example: PENTESTAGENT_MODEL=gpt-5 or PENTESTAGENT_MODEL=claude-sonnet-4-20250514"
            )
            return

        run_tui(target=None, model=DEFAULT_MODEL, use_docker=False)
        return


if __name__ == "__main__":
    main()
