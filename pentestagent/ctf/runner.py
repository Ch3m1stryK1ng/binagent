"""
Core CTF Runner for nc-based interactive challenges.

Captures full transcripts, structured metadata, and flag evidence for
audit-grade logging and regression testing.
"""

import json
import os
import re
import select
import socket
import subprocess
import sys
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, List, Dict, Any, Tuple


# =============================================================================
# Logging Utilities
# =============================================================================

def log(category: str, phase: str, message: str) -> None:
    """Structured logging with category markers."""
    timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
    print(f"[{timestamp}] [{category}] [{phase}] {message}", file=sys.stderr)


def log_ctf(phase: str, message: str) -> None:
    """Log CTF runner phase markers."""
    log("CTF", phase, message)


def log_tools(message: str) -> None:
    """Log network tool interaction."""
    log("TOOLS", "nc", message)


# =============================================================================
# Environment & Metadata Helpers
# =============================================================================

def get_git_commit() -> Optional[str]:
    """Get current git commit hash."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            return result.stdout.strip()[:12]
    except Exception:
        pass
    return None


def get_git_dirty() -> bool:
    """Check if working directory has uncommitted changes."""
    try:
        result = subprocess.run(
            ["git", "status", "--porcelain"],
            capture_output=True,
            text=True,
            timeout=5
        )
        return bool(result.stdout.strip())
    except Exception:
        return False


def get_model_from_env() -> Optional[str]:
    """Get model name from environment variables."""
    for var in ["PENTESTAGENT_MODEL", "OPENAI_MODEL", "ANTHROPIC_MODEL", "LLM_MODEL"]:
        if var in os.environ:
            return os.environ[var]
    return None


def generate_run_id() -> str:
    """Generate a timestamp-based run ID."""
    return datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S_%f")[:20]


# =============================================================================
# Transcript Builder
# =============================================================================

class TranscriptBuilder:
    """Builds an audit-grade transcript with clear input/output markers."""

    def __init__(self):
        self.entries: List[Tuple[str, str, float]] = []  # (type, data, timestamp)
        self.start_time: float = time.time()

    def add_received(self, data: str) -> None:
        """Record received data from server."""
        self.entries.append(("RECV", data, time.time() - self.start_time))

    def add_sent(self, data: str) -> None:
        """Record sent data to server."""
        self.entries.append(("SEND", data, time.time() - self.start_time))

    def add_event(self, event: str) -> None:
        """Record an event (connect, disconnect, timeout, etc.)."""
        self.entries.append(("EVENT", event, time.time() - self.start_time))

    def clear(self) -> None:
        """Clear all entries and reset start time."""
        self.entries = []
        self.start_time = time.time()

    def to_text(self) -> str:
        """Generate human-readable transcript."""
        lines = []
        lines.append("=" * 70)
        lines.append("CTF RUNNER TRANSCRIPT")
        lines.append("=" * 70)
        lines.append("")

        for entry_type, data, ts in self.entries:
            ts_str = f"[{ts:8.3f}s]"
            if entry_type == "EVENT":
                lines.append(f"{ts_str} >>> {data}")
            elif entry_type == "SEND":
                # Show sent data with escape sequences visible
                escaped = data.encode('unicode_escape').decode('ascii')
                lines.append(f"{ts_str} [SEND] {escaped}")
            elif entry_type == "RECV":
                lines.append(f"{ts_str} [RECV]")
                # Indent received content
                for line in data.split('\n'):
                    lines.append(f"         | {line}")

        lines.append("")
        lines.append("=" * 70)
        lines.append("END TRANSCRIPT")
        lines.append("=" * 70)
        return "\n".join(lines)

    def to_json(self) -> List[Dict[str, Any]]:
        """Generate JSON-serializable transcript."""
        return [
            {"type": t, "data": d, "elapsed_sec": round(ts, 4)}
            for t, d, ts in self.entries
        ]


# =============================================================================
# CTF Runner Core
# =============================================================================

class CTFRunner:
    """
    Core CTF runner for nc-based interactive challenges.

    Supports two modes:
    - blind: Send payload N times regardless of prompts
    - prompted: Wait for prompt regex before sending each payload
    """

    def __init__(
        self,
        host: str,
        port: int,
        payload: str,
        repeat: int = 1,
        timeout: float = 10.0,
        prompt_regex: str = r"[Cc]rowd:",
        flag_regex: str = r"picoCTF\{[^}]+\}",
        mode: str = "blind",
        run_id: Optional[str] = None,
        out_dir: Optional[str] = None,
        save_artifacts: bool = True,
    ):
        self.host = host
        self.port = port
        self.payload = payload
        self.repeat = repeat
        self.timeout = timeout
        self.prompt_regex = re.compile(prompt_regex)
        self.flag_regex = re.compile(flag_regex)
        self.mode = mode
        self.run_id = run_id or generate_run_id()
        self.save_artifacts_enabled = save_artifacts

        # Output directory
        if out_dir:
            self.out_dir = Path(out_dir)
        else:
            self.out_dir = Path("runs") / self.run_id

        # State
        self.transcript = TranscriptBuilder()
        self.all_output = ""
        self.bytes_sent = 0
        self.bytes_received = 0
        self.flags_found: List[Dict[str, Any]] = []
        self.success = False
        self.error: Optional[str] = None
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None

    def run(self) -> bool:
        """Execute the CTF run. Returns True if flag found."""
        log_ctf("connect", f"Connecting to {self.host}:{self.port}")
        self.start_time = time.time()

        try:
            self._execute()
        except Exception as e:
            self.error = str(e)
            log_ctf("error", f"Run failed: {e}")
        finally:
            self.end_time = time.time()

        # Extract flags
        log_ctf("extract", "Searching for flags in output")
        self._extract_flags()

        # Save artifacts
        if self.save_artifacts_enabled:
            log_ctf("done", f"Saving artifacts to {self.out_dir}")
            self.save_artifacts()

        # Summary
        elapsed = self.end_time - self.start_time
        log_tools(f"bytes_in={self.bytes_received} bytes_out={self.bytes_sent} "
                  f"elapsed={elapsed:.2f}s timeout={self.timeout}s host={self.host}:{self.port}")

        return self.success

    def _execute(self) -> None:
        """Execute the network interaction."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)

        try:
            sock.connect((self.host, self.port))
            self.transcript.add_event(f"Connected to {self.host}:{self.port}")
            log_ctf("probe", "Connection established, reading initial output")

            if self.mode == "blind":
                self._run_blind_mode(sock)
            else:
                self._run_prompted_mode(sock)

        except socket.timeout:
            self.transcript.add_event("Connection timeout")
            log_ctf("interact", "Connection timed out (expected)")
        except ConnectionRefusedError:
            self.transcript.add_event("Connection refused")
            self.error = "Connection refused"
            raise
        finally:
            sock.close()
            self.transcript.add_event("Connection closed")

    def _run_blind_mode(self, sock: socket.socket) -> None:
        """Blind mode: send all payloads at once, then read."""
        log_ctf("interact", f"Blind mode: sending payload {self.repeat} times")

        # Build full payload
        full_payload = self.payload * self.repeat

        # Send all at once
        self._send(sock, full_payload)

        # Read until timeout
        self._read_until_timeout(sock)

    def _run_prompted_mode(self, sock: socket.socket) -> None:
        """Prompted mode: wait for prompt before each send."""
        log_ctf("interact", f"Prompted mode: waiting for '{self.prompt_regex.pattern}' before each send")

        for i in range(self.repeat):
            # Read until we see the prompt
            if not self._read_until_prompt(sock):
                log_ctf("interact", f"Prompt not found after iteration {i}")
                break

            # Send one payload
            self._send(sock, self.payload)
            log_ctf("interact", f"Sent payload {i+1}/{self.repeat}")

        # Read remaining output
        self._read_until_timeout(sock)

    def _send(self, sock: socket.socket, data: str) -> None:
        """Send data and record in transcript."""
        encoded = data.encode('utf-8')
        sock.sendall(encoded)
        self.bytes_sent += len(encoded)
        self.transcript.add_sent(data)

    def _read_until_timeout(self, sock: socket.socket) -> None:
        """Read all available data until timeout."""
        sock.setblocking(False)
        deadline = time.time() + self.timeout

        while time.time() < deadline:
            remaining = deadline - time.time()
            if remaining <= 0:
                break

            ready, _, _ = select.select([sock], [], [], min(remaining, 0.5))
            if ready:
                try:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    decoded = chunk.decode('utf-8', errors='replace')
                    self.all_output += decoded
                    self.bytes_received += len(chunk)
                    self.transcript.add_received(decoded)
                except BlockingIOError:
                    continue
                except Exception:
                    break

    def _read_until_prompt(self, sock: socket.socket) -> bool:
        """Read until prompt regex is found. Returns True if found."""
        sock.setblocking(False)
        deadline = time.time() + self.timeout
        buffer = ""

        while time.time() < deadline:
            remaining = deadline - time.time()
            if remaining <= 0:
                break

            ready, _, _ = select.select([sock], [], [], min(remaining, 0.5))
            if ready:
                try:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    decoded = chunk.decode('utf-8', errors='replace')
                    buffer += decoded
                    self.all_output += decoded
                    self.bytes_received += len(chunk)
                    self.transcript.add_received(decoded)

                    # Check for prompt
                    if self.prompt_regex.search(buffer):
                        return True
                except BlockingIOError:
                    continue
                except Exception:
                    break

        return False

    def _extract_flags(self) -> None:
        """Extract flags from collected output."""
        lines = self.all_output.split('\n')
        for line_num, line in enumerate(lines, 1):
            for match in self.flag_regex.finditer(line):
                flag_info = {
                    "flag": match.group(0),
                    "line_number": line_num,
                    "start_pos": match.start(),
                    "end_pos": match.end(),
                    "context": line.strip()[:200]
                }
                self.flags_found.append(flag_info)
                log_ctf("extract", f"Found flag: {match.group(0)} at line {line_num}")

        self.success = len(self.flags_found) > 0

    def save_artifacts(self, extra_metadata: Optional[Dict[str, Any]] = None) -> None:
        """Save transcript, metadata, and summary."""
        self.out_dir.mkdir(parents=True, exist_ok=True)

        # 1. Transcript (human-readable)
        transcript_path = self.out_dir / "transcript.txt"
        with open(transcript_path, 'w') as f:
            f.write(self.transcript.to_text())

        # 2. Run metadata (run.json)
        run_meta = {
            "run_id": self.run_id,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "host": self.host,
            "port": self.port,
            "payload": self.payload,
            "payload_escaped": self.payload.encode('unicode_escape').decode('ascii'),
            "repeat": self.repeat,
            "timeout": self.timeout,
            "mode": self.mode,
            "prompt_regex": self.prompt_regex.pattern,
            "flag_regex": self.flag_regex.pattern,
            "model": get_model_from_env(),
            "git_commit": get_git_commit(),
            "git_dirty": get_git_dirty(),
            "transcript": self.transcript.to_json(),
        }
        if extra_metadata:
            run_meta.update(extra_metadata)

        run_path = self.out_dir / "run.json"
        with open(run_path, 'w') as f:
            json.dump(run_meta, f, indent=2)

        # 3. Summary (summary.json)
        elapsed = (self.end_time - self.start_time) if self.end_time and self.start_time else 0
        summary = {
            "run_id": self.run_id,
            "success": self.success,
            "flags": self.flags_found,
            "flag_count": len(self.flags_found),
            "bytes_sent": self.bytes_sent,
            "bytes_received": self.bytes_received,
            "elapsed_seconds": round(elapsed, 3),
            "error": self.error,
        }
        summary_path = self.out_dir / "summary.json"
        with open(summary_path, 'w') as f:
            json.dump(summary, f, indent=2)

        log_ctf("done", f"Artifacts saved: transcript.txt, run.json, summary.json")

    def reset(self) -> None:
        """Reset state for a new run (same host/port)."""
        self.transcript = TranscriptBuilder()
        self.all_output = ""
        self.bytes_sent = 0
        self.bytes_received = 0
        self.flags_found = []
        self.success = False
        self.error = None
        self.start_time = None
        self.end_time = None
