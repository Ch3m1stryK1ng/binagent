"""
Auto-solver for picoCTF-style interactive challenges.

Implements heuristic payload strategies with bounded attempts.
"""

import json
import sys
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, List, Dict, Any

from .runner import CTFRunner, TranscriptBuilder, generate_run_id, log_ctf


@dataclass
class PayloadStrategy:
    """A payload strategy to try."""
    name: str
    payload: str
    repeat: int
    mode: str = "blind"
    description: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "payload": self.payload,
            "payload_escaped": self.payload.encode('unicode_escape').decode('ascii'),
            "repeat": self.repeat,
            "mode": self.mode,
            "description": self.description,
        }


# Default payload strategies for picoCTF-style interactive challenges
DEFAULT_STRATEGIES: List[PayloadStrategy] = [
    PayloadStrategy(
        name="baseline",
        payload="test\n",
        repeat=8,
        mode="blind",
        description="Simple test input to observe normal behavior",
    ),
    PayloadStrategy(
        name="semicolon_return_0",
        payload="test;RETURN 0\n",
        repeat=8,
        mode="blind",
        description="Semicolon delimiter with RETURN 0 (common CTF pattern)",
    ),
    PayloadStrategy(
        name="semicolon_return_1",
        payload="A;RETURN 1\n",
        repeat=8,
        mode="blind",
        description="Semicolon delimiter with RETURN 1",
    ),
    PayloadStrategy(
        name="semicolon_return_2",
        payload="X;RETURN 2\n",
        repeat=8,
        mode="blind",
        description="Semicolon delimiter with RETURN 2",
    ),
    PayloadStrategy(
        name="semicolon_return_3",
        payload="Y;RETURN 3\n",
        repeat=8,
        mode="blind",
        description="Semicolon delimiter with RETURN 3",
    ),
]


@dataclass
class AttemptResult:
    """Result of a single solve attempt."""
    strategy: PayloadStrategy
    success: bool
    flags: List[Dict[str, Any]]
    error: Optional[str]
    elapsed_seconds: float
    bytes_sent: int
    bytes_received: int
    transcript_json: List[Dict[str, Any]]


@dataclass
class SolveResult:
    """Result of the complete auto-solve process."""
    run_id: str
    host: str
    port: int
    success: bool
    flags: List[Dict[str, Any]]
    winning_strategy: Optional[PayloadStrategy]
    attempts: List[AttemptResult]
    total_elapsed_seconds: float
    out_dir: Path
    error: Optional[str] = None


class CTFAutoSolver:
    """
    Automatic CTF solver that tries multiple payload strategies.

    Connects to the target, tries strategies in order, and stops
    on first success. Produces audit-grade artifacts.
    """

    def __init__(
        self,
        host: str,
        port: int,
        timeout: float = 15.0,
        prompt_regex: str = r"[Cc]rowd:",
        flag_regex: str = r"picoCTF\{[^}]+\}",
        strategies: Optional[List[PayloadStrategy]] = None,
        max_attempts: int = 10,
        run_id: Optional[str] = None,
        out_dir: Optional[str] = None,
        description: str = "",
    ):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.prompt_regex = prompt_regex
        self.flag_regex = flag_regex
        self.strategies = strategies or DEFAULT_STRATEGIES
        self.max_attempts = max_attempts
        self.run_id = run_id or generate_run_id()
        self.description = description

        # Output directory
        if out_dir:
            self.out_dir = Path(out_dir)
        else:
            self.out_dir = Path("runs") / self.run_id

        # State
        self.attempts: List[AttemptResult] = []
        self.winning_strategy: Optional[PayloadStrategy] = None
        self.all_flags: List[Dict[str, Any]] = []

    def solve(self) -> SolveResult:
        """
        Attempt to solve the challenge using the configured strategies.

        Returns:
            SolveResult with all attempt details and artifacts
        """
        log_ctf("parse", f"Target: {self.host}:{self.port}")
        log_ctf("parse", f"Strategies to try: {len(self.strategies)}")

        start_time = time.time()
        error = None

        for i, strategy in enumerate(self.strategies[:self.max_attempts]):
            log_ctf("attempt", f"Trying strategy {i+1}/{len(self.strategies)}: {strategy.name}")

            result = self._try_strategy(strategy)
            self.attempts.append(result)

            if result.success:
                log_ctf("attempt", f"SUCCESS with strategy: {strategy.name}")
                self.winning_strategy = strategy
                self.all_flags.extend(result.flags)
                break
            elif result.error and "Connection refused" in result.error:
                log_ctf("attempt", "Connection refused - challenge instance may be down")
                error = result.error
                break
            else:
                log_ctf("attempt", f"No flag found with {strategy.name}")

        total_elapsed = time.time() - start_time
        success = len(self.all_flags) > 0

        # Save artifacts
        log_ctf("done", f"Saving artifacts to {self.out_dir}")
        self._save_artifacts(total_elapsed, error)

        return SolveResult(
            run_id=self.run_id,
            host=self.host,
            port=self.port,
            success=success,
            flags=self.all_flags,
            winning_strategy=self.winning_strategy,
            attempts=self.attempts,
            total_elapsed_seconds=total_elapsed,
            out_dir=self.out_dir,
            error=error,
        )

    def _try_strategy(self, strategy: PayloadStrategy) -> AttemptResult:
        """Try a single payload strategy."""
        runner = CTFRunner(
            host=self.host,
            port=self.port,
            payload=strategy.payload,
            repeat=strategy.repeat,
            timeout=self.timeout,
            prompt_regex=self.prompt_regex,
            flag_regex=self.flag_regex,
            mode=strategy.mode,
            run_id=f"{self.run_id}_{strategy.name}",
            save_artifacts=False,  # We'll save combined artifacts
        )

        try:
            runner.run()
        except Exception as e:
            pass  # Error is captured in runner.error

        return AttemptResult(
            strategy=strategy,
            success=runner.success,
            flags=runner.flags_found,
            error=runner.error,
            elapsed_seconds=(runner.end_time - runner.start_time) if runner.end_time and runner.start_time else 0,
            bytes_sent=runner.bytes_sent,
            bytes_received=runner.bytes_received,
            transcript_json=runner.transcript.to_json(),
        )

    def _save_artifacts(self, total_elapsed: float, error: Optional[str]) -> None:
        """Save combined artifacts for all attempts."""
        self.out_dir.mkdir(parents=True, exist_ok=True)

        # 1. Combined transcript
        transcript_lines = [
            "=" * 70,
            "CTF AUTO-SOLVER TRANSCRIPT",
            f"Target: {self.host}:{self.port}",
            f"Run ID: {self.run_id}",
            "=" * 70,
            "",
        ]

        for i, attempt in enumerate(self.attempts, 1):
            transcript_lines.append(f"--- Attempt {i}: {attempt.strategy.name} ---")
            transcript_lines.append(f"Payload: {repr(attempt.strategy.payload)}")
            transcript_lines.append(f"Repeat: {attempt.strategy.repeat}")
            transcript_lines.append(f"Success: {attempt.success}")
            if attempt.flags:
                for flag in attempt.flags:
                    transcript_lines.append(f"FLAG: {flag['flag']} (line {flag['line_number']})")
            transcript_lines.append("")

            for entry in attempt.transcript_json:
                ts_str = f"[{entry['elapsed_sec']:8.3f}s]"
                if entry['type'] == "EVENT":
                    transcript_lines.append(f"{ts_str} >>> {entry['data']}")
                elif entry['type'] == "SEND":
                    escaped = entry['data'].encode('unicode_escape').decode('ascii')
                    transcript_lines.append(f"{ts_str} [SEND] {escaped}")
                elif entry['type'] == "RECV":
                    transcript_lines.append(f"{ts_str} [RECV]")
                    for line in entry['data'].split('\n'):
                        transcript_lines.append(f"         | {line}")

            transcript_lines.append("")

        transcript_lines.extend([
            "=" * 70,
            "END TRANSCRIPT",
            "=" * 70,
        ])

        transcript_path = self.out_dir / "transcript.txt"
        with open(transcript_path, 'w') as f:
            f.write("\n".join(transcript_lines))

        # 2. Run metadata (run.json)
        run_meta = {
            "run_id": self.run_id,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "host": self.host,
            "port": self.port,
            "description": self.description,
            "timeout": self.timeout,
            "prompt_regex": self.prompt_regex,
            "flag_regex": self.flag_regex,
            "strategies_tried": [a.strategy.to_dict() for a in self.attempts],
            "winning_strategy": self.winning_strategy.to_dict() if self.winning_strategy else None,
            "attempts": [
                {
                    "strategy_name": a.strategy.name,
                    "success": a.success,
                    "flags": a.flags,
                    "error": a.error,
                    "elapsed_seconds": round(a.elapsed_seconds, 3),
                    "bytes_sent": a.bytes_sent,
                    "bytes_received": a.bytes_received,
                }
                for a in self.attempts
            ],
        }

        run_path = self.out_dir / "run.json"
        with open(run_path, 'w') as f:
            json.dump(run_meta, f, indent=2)

        # 3. Summary (summary.json)
        summary = {
            "run_id": self.run_id,
            "success": len(self.all_flags) > 0,
            "flags": self.all_flags,
            "flag_count": len(self.all_flags),
            "winning_strategy": self.winning_strategy.name if self.winning_strategy else None,
            "attempts_count": len(self.attempts),
            "total_elapsed_seconds": round(total_elapsed, 3),
            "error": error,
        }

        summary_path = self.out_dir / "summary.json"
        with open(summary_path, 'w') as f:
            json.dump(summary, f, indent=2)

        log_ctf("done", "Artifacts saved: transcript.txt, run.json, summary.json")


def run_auto_solve(
    host: str,
    port: int,
    description: str = "",
    timeout: float = 15.0,
    max_attempts: int = 10,
    run_id: Optional[str] = None,
    out_dir: Optional[str] = None,
    prompt_regex: str = r"[Cc]rowd:",
    flag_regex: str = r"picoCTF\{[^}]+\}",
) -> SolveResult:
    """
    Convenience function to run the auto-solver.

    Args:
        host: Target hostname
        port: Target port
        description: Challenge description (for logging)
        timeout: Connection timeout per attempt
        max_attempts: Maximum number of strategies to try
        run_id: Optional custom run ID
        out_dir: Optional output directory
        prompt_regex: Regex to detect prompts
        flag_regex: Regex to extract flags

    Returns:
        SolveResult with all details
    """
    solver = CTFAutoSolver(
        host=host,
        port=port,
        timeout=timeout,
        prompt_regex=prompt_regex,
        flag_regex=flag_regex,
        max_attempts=max_attempts,
        run_id=run_id,
        out_dir=out_dir,
        description=description,
    )

    return solver.solve()
