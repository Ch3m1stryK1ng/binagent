"""
Parser utilities for extracting CTF challenge information from descriptions.
"""

import re
from dataclasses import dataclass
from typing import Optional, List, Tuple


@dataclass
class ParsedTarget:
    """Parsed nc target information."""
    host: str
    port: int
    raw_match: str  # The original matched string

    def __str__(self) -> str:
        return f"{self.host}:{self.port}"


def parse_nc_target(text: str) -> Optional[ParsedTarget]:
    """
    Extract nc host port from a challenge description.

    Handles various formats:
    - nc hostname port
    - nc hostname:port
    - Connect: nc hostname port
    - $ nc hostname port
    - ncat hostname port
    - hostname:port (standalone, requires domain-like structure)

    Args:
        text: Challenge description or command string

    Returns:
        ParsedTarget if found, None otherwise
    """
    # Patterns ordered by specificity (most specific first)
    patterns = [
        # nc/ncat with explicit host and port
        r'(?:nc|ncat)\s+([a-zA-Z0-9][a-zA-Z0-9\.\-]+)\s+(\d{1,5})',
        # nc/ncat with host:port
        r'(?:nc|ncat)\s+([a-zA-Z0-9][a-zA-Z0-9\.\-]+):(\d{1,5})',
        # Standalone host:port (requires at least one dot to look like a domain)
        r'\b([a-zA-Z0-9][a-zA-Z0-9\-]*\.[a-zA-Z0-9\.\-]+):(\d{1,5})\b',
    ]

    for pattern in patterns:
        match = re.search(pattern, text)
        if match:
            host = match.group(1)
            port_str = match.group(2)

            # Validate port
            try:
                port = int(port_str)
                if 1 <= port <= 65535:
                    return ParsedTarget(
                        host=host,
                        port=port,
                        raw_match=match.group(0)
                    )
            except ValueError:
                continue

    return None


def parse_all_nc_targets(text: str) -> List[ParsedTarget]:
    """
    Extract all nc targets from text (useful if multiple are present).

    Returns:
        List of ParsedTarget objects
    """
    targets = []
    seen = set()

    patterns = [
        r'(?:nc|ncat)\s+([a-zA-Z0-9][a-zA-Z0-9\.\-]+)\s+(\d{1,5})',
        r'(?:nc|ncat)\s+([a-zA-Z0-9][a-zA-Z0-9\.\-]+):(\d{1,5})',
        r'\b([a-zA-Z0-9][a-zA-Z0-9\-]*\.[a-zA-Z0-9\.\-]+):(\d{1,5})\b',
    ]

    for pattern in patterns:
        for match in re.finditer(pattern, text):
            host = match.group(1)
            try:
                port = int(match.group(2))
                if 1 <= port <= 65535:
                    key = (host, port)
                    if key not in seen:
                        seen.add(key)
                        targets.append(ParsedTarget(
                            host=host,
                            port=port,
                            raw_match=match.group(0)
                        ))
            except ValueError:
                continue

    return targets


def parse_connect_string(connect_str: str) -> Optional[ParsedTarget]:
    """
    Parse a host:port connect string.

    Args:
        connect_str: String like "hostname:port" or "hostname port"

    Returns:
        ParsedTarget if valid, None otherwise
    """
    # Try host:port
    if ':' in connect_str:
        parts = connect_str.split(':')
        if len(parts) == 2:
            host = parts[0].strip()
            port_str = parts[1].strip()
            # Host must be non-empty and look like a valid hostname
            if host and re.match(r'^[a-zA-Z0-9][a-zA-Z0-9\.\-]*$', host):
                try:
                    port = int(port_str)
                    if 1 <= port <= 65535:
                        return ParsedTarget(host=host, port=port, raw_match=connect_str)
                except ValueError:
                    pass

    # Try host port (space separated)
    parts = connect_str.split()
    if len(parts) == 2:
        host = parts[0].strip()
        # Host must look like a valid hostname
        if re.match(r'^[a-zA-Z0-9][a-zA-Z0-9\.\-]*$', host):
            try:
                port = int(parts[1].strip())
                if 1 <= port <= 65535:
                    return ParsedTarget(host=host, port=port, raw_match=connect_str)
            except ValueError:
                pass

    return None


def detect_prompt_pattern(text: str) -> Optional[str]:
    """
    Try to detect a prompt pattern from challenge description.

    Args:
        text: Challenge description

    Returns:
        Regex pattern string if detected, None otherwise
    """
    # Common prompt patterns in CTF challenges
    prompt_indicators = [
        (r'prompts?\s+["\']([^"\']+)["\']', 1),  # prompts "Crowd:"
        (r'enter\s+(?:your\s+)?input\s+at\s+["\']([^"\']+)["\']', 1),
        (r'waits?\s+for\s+["\']([^"\']+)["\']', 1),
    ]

    for pattern, group in prompt_indicators:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            return re.escape(match.group(group))

    # Check for common CTF prompts mentioned
    common_prompts = ['Crowd:', 'Input:', 'Enter:', '>', '>>>', '$', '#']
    for prompt in common_prompts:
        if prompt in text:
            return re.escape(prompt)

    return None


def detect_flag_pattern(text: str) -> str:
    """
    Detect the flag pattern from challenge description.

    Args:
        text: Challenge description

    Returns:
        Regex pattern string (defaults to picoCTF)
    """
    # Check for explicit flag format mentions
    format_patterns = [
        (r'flag\s+format[:\s]+(\w+)\{', r'{}\{{[^}}]+\}}'),  # "flag format: CTF{"
        (r'(\w+CTF)\{', r'{}\{{[^}}]+\}}'),  # matches "picoCTF{", "flagCTF{" etc
    ]

    for pattern, template in format_patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            prefix = match.group(1)
            return template.format(prefix)

    # Default to picoCTF
    return r'picoCTF\{[^}]+\}'
