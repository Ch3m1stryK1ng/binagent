"""Unit tests for APK CTF solver."""

import pytest
from ..solver import (
    decode_base64,
    decode_base32,
    decode_hex,
    decode_rot13,
    try_xor_bruteforce,
    is_printable_text,
    BASE64_PATTERN,
    BASE32_PATTERN,
    HEX_PATTERN,
    DEFAULT_FLAG_PATTERNS,
    FlagEvidence,
    PatternHit,
    DecodeAttempt,
    SolverResult,
)
import re


class TestDecoders:
    """Test decoder functions."""

    def test_decode_base64_valid(self):
        """Test valid base64 decoding."""
        # "hello world" in base64
        result = decode_base64("aGVsbG8gd29ybGQ=")
        assert result == "hello world"

    def test_decode_base64_without_padding(self):
        """Test base64 without padding."""
        # Should auto-pad
        result = decode_base64("aGVsbG8gd29ybGQ")
        assert result == "hello world"

    def test_decode_base64_invalid(self):
        """Test invalid base64 returns None."""
        result = decode_base64("not valid base64!!!")
        assert result is None

    def test_decode_base64_binary_data(self):
        """Test base64 that decodes to non-printable returns None."""
        # Random bytes that aren't printable text
        result = decode_base64("////")
        assert result is None

    def test_decode_base32_valid(self):
        """Test valid base32 decoding."""
        # "hello" in base32
        result = decode_base32("NBSWY3DP")
        assert result == "hello"

    def test_decode_base32_with_flag(self):
        """Test base32 that decodes to a flag."""
        import base64
        flag = "picoCTF{test_flag_123}"
        encoded = base64.b32encode(flag.encode()).decode()
        result = decode_base32(encoded)
        assert result == flag

    def test_decode_base32_lowercase(self):
        """Test base32 with lowercase input (should normalize)."""
        result = decode_base32("nbswy3dp")
        assert result == "hello"

    def test_decode_base32_invalid(self):
        """Test invalid base32 returns None."""
        result = decode_base32("not valid!")
        assert result is None

    def test_decode_hex_valid(self):
        """Test valid hex decoding."""
        # "hello" in hex
        result = decode_hex("68656c6c6f")
        assert result == "hello"

    def test_decode_hex_uppercase(self):
        """Test hex with uppercase."""
        result = decode_hex("48454C4C4F")
        assert result == "HELLO"

    def test_decode_hex_invalid(self):
        """Test invalid hex returns None."""
        result = decode_hex("ZZZZ")
        assert result is None

    def test_decode_hex_odd_length(self):
        """Test odd-length hex returns None."""
        result = decode_hex("123")
        assert result is None

    def test_decode_rot13(self):
        """Test ROT13 decoding."""
        result = decode_rot13("uryyb")
        assert result == "hello"

    def test_decode_rot13_preserves_case(self):
        """Test ROT13 preserves case."""
        result = decode_rot13("Uryyb Jbeyq")
        assert result == "Hello World"

    def test_decode_rot13_preserves_nonalpha(self):
        """Test ROT13 preserves non-alpha characters."""
        result = decode_rot13("cvpbPGS{grfg_123}")
        assert result == "picoCTF{test_123}"


class TestPatternMatching:
    """Test pattern regex matching."""

    def test_base64_pattern_matches_valid(self):
        """Test base64 pattern matches valid tokens (16+ chars)."""
        valid_tokens = [
            "aGVsbG8gd29ybGQgdGVzdA==",  # "hello world test" - long enough
            "ABCDEFGHIJKLMNOP",  # exactly 16 chars
            "abcdefghijklmnopqrstuvwx+/==",  # longer with special chars
        ]
        for token in valid_tokens:
            assert re.search(BASE64_PATTERN, token), f"Should match: {token}"

    def test_base64_pattern_rejects_short(self):
        """Test base64 pattern rejects short tokens."""
        assert re.search(BASE64_PATTERN, "abc") is None

    def test_base32_pattern_matches_valid(self):
        """Test base32 pattern matches valid tokens."""
        valid_tokens = [
            "NBSWY3DPEB3W64TMMQ======",
            "ABCDEFGHIJKLMNOP",
        ]
        for token in valid_tokens:
            assert re.search(BASE32_PATTERN, token), f"Should match: {token}"

    def test_base32_pattern_rejects_lowercase(self):
        """Test base32 pattern rejects lowercase (it's A-Z2-7)."""
        # lowercase shouldn't match base32 pattern
        assert re.search(BASE32_PATTERN, "abcdefghijklmnop") is None

    def test_hex_pattern_matches_valid(self):
        """Test hex pattern matches valid tokens."""
        valid_tokens = [
            "68656c6c6f20776f726c64",
            "AABBCCDD11223344",
        ]
        for token in valid_tokens:
            assert re.search(HEX_PATTERN, token), f"Should match: {token}"

    def test_flag_patterns_match(self):
        """Test default flag patterns match common formats."""
        flags = [
            "picoCTF{test_flag_123}",
            "flag{another_test}",
            "CTF{yet_another}",
            "FLAG{UPPERCASE}",
        ]
        for flag in flags:
            matched = False
            for pattern in DEFAULT_FLAG_PATTERNS:
                if re.search(pattern, flag):
                    matched = True
                    break
            assert matched, f"Should match: {flag}"


class TestXORBruteforce:
    """Test XOR brute force decoding."""

    def test_xor_finds_flag(self):
        """Test XOR brute force finds a simple XORed flag."""
        flag = "picoCTF{xor_test}"
        key = 42
        xored = "".join(chr(ord(c) ^ key) for c in flag)

        result = try_xor_bruteforce(xored, DEFAULT_FLAG_PATTERNS, max_key=256)
        assert result is not None
        assert flag in result[0]
        assert "xor" in result[1].lower()

    def test_xor_returns_none_no_flag(self):
        """Test XOR returns None when no flag found."""
        result = try_xor_bruteforce("hello world", DEFAULT_FLAG_PATTERNS, max_key=256)
        assert result is None


class TestHelpers:
    """Test helper functions."""

    def test_is_printable_text_valid(self):
        """Test printable text detection."""
        assert is_printable_text(b"hello world")
        assert is_printable_text(b"picoCTF{test}")
        assert is_printable_text(b"line1\nline2\ttab")

    def test_is_printable_text_invalid(self):
        """Test non-printable detection."""
        assert not is_printable_text(b"\x00\x01\x02")
        assert not is_printable_text(b"\xff\xfe\xfd")


class TestDataClasses:
    """Test dataclass structures."""

    def test_flag_evidence_creation(self):
        """Test FlagEvidence dataclass."""
        ev = FlagEvidence(
            flag="picoCTF{test}",
            file="res/values/strings.xml",
            line=42,
            extract="<string name=\"test\">...",
            method="base32",
            input_token="NBSWY3DP...",
        )
        assert ev.flag == "picoCTF{test}"
        assert ev.method == "base32"

    def test_pattern_hit_creation(self):
        """Test PatternHit dataclass."""
        hit = PatternHit(
            file="test.java",
            line=10,
            pattern_type="base64_token",
            match="ABCDEFGH...",
            context="String s = \"ABCDEFGH...\"",
        )
        assert hit.pattern_type == "base64_token"

    def test_decode_attempt_creation(self):
        """Test DecodeAttempt dataclass."""
        attempt = DecodeAttempt(
            token="ABCD",
            method="base64",
            success=True,
            result="hello",
        )
        assert attempt.success
        assert attempt.result == "hello"

    def test_solver_result_defaults(self):
        """Test SolverResult default values."""
        result = SolverResult(success=False)
        assert result.flags == []
        assert result.hits == []
        assert result.decode_attempts == []
        assert result.stop_reason is None


class TestEvidenceFormatting:
    """Test evidence formatting for summary.json."""

    def test_flag_evidence_serializable(self):
        """Test FlagEvidence can be serialized to dict."""
        ev = FlagEvidence(
            flag="picoCTF{test}",
            file="test.xml",
            line=1,
            extract="context",
            method="base32",
            input_token="TOKEN",
        )
        # Should be convertible to dict for JSON
        data = {
            "flag": ev.flag,
            "evidence": {
                "file": ev.file,
                "line": ev.line,
                "extract": ev.extract,
                "method": ev.method,
                "input_token": ev.input_token,
            }
        }
        assert data["flag"] == "picoCTF{test}"
        assert data["evidence"]["method"] == "base32"


class TestDeterministicOrdering:
    """Test that solver operations are deterministic."""

    def test_decoder_order_is_stable(self):
        """Test decoders are tried in consistent order."""
        from ..solver import DECODERS
        names = [d[0] for d in DECODERS]
        # Order should be: base64, base32, hex, rot13
        assert names == ["base64", "base32", "hex", "rot13"]

    def test_flag_patterns_order_is_stable(self):
        """Test flag patterns are in consistent order."""
        # picoCTF should be first (most common in CTF context)
        assert "picoCTF" in DEFAULT_FLAG_PATTERNS[0]
