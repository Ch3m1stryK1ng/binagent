"""APK static analyzer - extracts artifacts and performs static analysis."""

import json
import os
import re
import shutil
import subprocess
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional


class ToolNotFoundError(Exception):
    """Raised when a required tool (jadx/apktool) is not found."""

    pass


@dataclass
class APKAnalysisResult:
    """Results from APK static analysis."""

    run_id: str
    apk_path: str
    out_dir: Path
    success: bool = False
    error: Optional[str] = None

    # Extracted info
    package_name: Optional[str] = None
    version_name: Optional[str] = None
    version_code: Optional[str] = None
    min_sdk: Optional[str] = None
    target_sdk: Optional[str] = None

    # Entry points
    activities: list = field(default_factory=list)
    services: list = field(default_factory=list)
    receivers: list = field(default_factory=list)
    providers: list = field(default_factory=list)
    permissions: list = field(default_factory=list)
    exported_components: list = field(default_factory=list)

    # Analysis results
    file_tree: list = field(default_factory=list)
    strings: list = field(default_factory=list)
    resources: list = field(default_factory=list)
    suspicious_hits: list = field(default_factory=list)

    # Stats
    total_files: int = 0
    total_classes: int = 0
    elapsed_seconds: float = 0.0


# Suspicious patterns for security analysis
SUSPICIOUS_PATTERNS = {
    # Crypto/Encoding
    "hardcoded_key": [
        r'(?i)(aes|des|rsa|secret|api[_-]?key|password|token)\s*[=:]\s*["\'][^"\']{8,}["\']',
        r'(?i)base64\.(encode|decode)',
    ],
    # Network
    "network_urls": [
        r'https?://[^\s"\'<>]+',
        r'(?i)(http|socket|connection|request)',
    ],
    # File operations
    "file_ops": [
        r'(?i)(file\.(read|write|delete)|openFileOutput|getExternalStorage)',
        r'/data/data/',
        r'/sdcard/',
    ],
    # Code execution
    "code_exec": [
        r'(?i)(runtime\.exec|processbuilder|\.loadClass|dexclassloader|pathclassloader)',
        r'(?i)(system\.load|native)',
    ],
    # Sensitive data
    "sensitive_data": [
        r'(?i)(imei|imsi|android_id|device_id|serial)',
        r'(?i)(getLine1Number|getDeviceId|getSubscriberId)',
        r'(?i)(sms|contacts|call_log|calendar)',
    ],
    # Dangerous permissions
    "dangerous_perms": [
        r'(?i)(SEND_SMS|READ_SMS|RECEIVE_SMS)',
        r'(?i)(READ_CONTACTS|WRITE_CONTACTS)',
        r'(?i)(ACCESS_FINE_LOCATION|ACCESS_COARSE_LOCATION)',
        r'(?i)(RECORD_AUDIO|CAMERA)',
        r'(?i)(READ_CALL_LOG|WRITE_CALL_LOG)',
        r'(?i)(INSTALL_PACKAGES|DELETE_PACKAGES)',
    ],
    # Reflection/Dynamic
    "reflection": [
        r'(?i)(Class\.forName|getDeclaredMethod|invoke\()',
        r'(?i)(getMethod|getDeclaredField)',
    ],
    # Obfuscation indicators
    "obfuscation": [
        r'\b[a-z]{1,2}\.[a-z]{1,2}\.[a-z]{1,2}\b',  # Short class names like a.b.c
        r'(?i)(proguard|dexguard|allatori)',
    ],
    # Root detection
    "root_detection": [
        r'(?i)(supersu|superuser|magisk|busybox)',
        r'(?i)(\/system\/app\/Superuser|\/system\/xbin\/su)',
        r'(?i)(isRooted|checkRoot|detectRoot)',
    ],
    # SSL/TLS issues
    "ssl_issues": [
        r'(?i)(trustAllCerts|AllowAllHostnameVerifier|ALLOW_ALL_HOSTNAME_VERIFIER)',
        r'(?i)(checkServerTrusted.*\{\s*\}|X509TrustManager)',
        r'(?i)(setHostnameVerifier|SSLSocketFactory)',
    ],
    # Logging/Debug
    "debug_info": [
        r'(?i)(Log\.(d|v|i|w|e)\(|System\.out\.print|printStackTrace)',
        r'(?i)(BuildConfig\.DEBUG|isDebuggable)',
    ],
    # WebView vulnerabilities
    "webview_vulns": [
        r'(?i)(setJavaScriptEnabled\s*\(\s*true|addJavascriptInterface)',
        r'(?i)(setAllowFileAccess|setAllowContentAccess)',
        r'(?i)(WebView|loadUrl|loadData)',
    ],
    # SQL
    "sql_injection": [
        r'(?i)(rawQuery|execSQL|SELECT.*FROM.*WHERE)',
        r'(?i)(SQLiteDatabase|ContentValues)',
    ],
    # Clipboard
    "clipboard": [
        r'(?i)(ClipboardManager|getPrimaryClip|setPrimaryClip)',
    ],
    # Crypto misuse
    "crypto_misuse": [
        r'(?i)(ECB|DES|MD5|SHA1)\b',
        r'(?i)(SecretKeySpec|Cipher\.getInstance)',
        r'(?i)(PBKDF2|AES/CBC)',
    ],
}


class APKAnalyzer:
    """Static analyzer for Android APK files."""

    def __init__(self, apk_path: str, run_id: Optional[str] = None):
        """
        Initialize the APK analyzer.

        Args:
            apk_path: Path to the APK file
            run_id: Optional run identifier (auto-generated if not provided)
        """
        self.apk_path = Path(apk_path).resolve()
        self.run_id = run_id or datetime.now().strftime("%Y%m%d_%H%M%S")
        self.out_dir = Path("runs") / self.run_id
        self.extracted_dir: Optional[Path] = None
        self.decompiled_dir: Optional[Path] = None

    def check_tools(self) -> dict:
        """
        Check if required tools are available.

        Returns:
            Dict with tool paths or None if not found

        Raises:
            ToolNotFoundError: If a required tool is missing
        """
        tools = {}

        # Check jadx
        jadx_path = shutil.which("jadx")
        if not jadx_path:
            # Try common locations
            common_paths = [
                "/usr/local/bin/jadx",
                "/usr/bin/jadx",
                os.path.expanduser("~/jadx/bin/jadx"),
                os.path.expanduser("~/.local/bin/jadx"),
            ]
            for p in common_paths:
                if os.path.isfile(p) and os.access(p, os.X_OK):
                    jadx_path = p
                    break

        if not jadx_path:
            raise ToolNotFoundError(
                "jadx not found.\n\n"
                "Install jadx:\n"
                "  Ubuntu/Debian: sudo apt install jadx\n"
                "  macOS:         brew install jadx\n"
                "  Manual:        https://github.com/skylot/jadx/releases\n"
                "                 Extract and add bin/ to PATH"
            )
        tools["jadx"] = jadx_path

        # Check apktool
        apktool_path = shutil.which("apktool")
        if not apktool_path:
            common_paths = [
                "/usr/local/bin/apktool",
                "/usr/bin/apktool",
                os.path.expanduser("~/apktool/apktool"),
                os.path.expanduser("~/.local/bin/apktool"),
            ]
            for p in common_paths:
                if os.path.isfile(p) and os.access(p, os.X_OK):
                    apktool_path = p
                    break

        if not apktool_path:
            raise ToolNotFoundError(
                "apktool not found.\n\n"
                "Install apktool:\n"
                "  Ubuntu/Debian: sudo apt install apktool\n"
                "  macOS:         brew install apktool\n"
                "  Manual:        https://ibotpeaches.github.io/Apktool/install/"
            )
        tools["apktool"] = apktool_path

        return tools

    def analyze(self) -> APKAnalysisResult:
        """
        Run full static analysis on the APK.

        Returns:
            APKAnalysisResult with all findings
        """
        import time

        start_time = time.time()

        result = APKAnalysisResult(
            run_id=self.run_id,
            apk_path=str(self.apk_path),
            out_dir=self.out_dir,
        )

        try:
            # Validate APK exists
            if not self.apk_path.exists():
                raise FileNotFoundError(f"APK not found: {self.apk_path}")

            if not self.apk_path.suffix.lower() == ".apk":
                raise ValueError(f"File is not an APK: {self.apk_path}")

            # Check tools
            tools = self.check_tools()

            # Create output directory
            self.out_dir.mkdir(parents=True, exist_ok=True)

            # Step 1: Extract with apktool
            self._extract_apktool(tools["apktool"])

            # Step 2: Decompile with jadx
            self._decompile_jadx(tools["jadx"])

            # Step 3: Parse manifest
            manifest_info = self._parse_manifest()
            result.package_name = manifest_info.get("package")
            result.version_name = manifest_info.get("version_name")
            result.version_code = manifest_info.get("version_code")
            result.min_sdk = manifest_info.get("min_sdk")
            result.target_sdk = manifest_info.get("target_sdk")
            result.activities = manifest_info.get("activities", [])
            result.services = manifest_info.get("services", [])
            result.receivers = manifest_info.get("receivers", [])
            result.providers = manifest_info.get("providers", [])
            result.permissions = manifest_info.get("permissions", [])
            result.exported_components = manifest_info.get("exported", [])

            # Step 4: Generate file tree
            result.file_tree, result.total_files = self._generate_file_tree()

            # Step 5: Extract strings
            result.strings = self._extract_strings()

            # Step 6: List resources
            result.resources = self._list_resources()

            # Step 7: Scan for suspicious patterns
            result.suspicious_hits = self._scan_suspicious()

            # Step 8: Count classes
            result.total_classes = self._count_classes()

            # Save artifacts
            self._save_artifacts(result)

            result.success = True

        except ToolNotFoundError as e:
            result.error = str(e)
        except Exception as e:
            result.error = f"Analysis failed: {e}"

        result.elapsed_seconds = time.time() - start_time
        return result

    def _extract_apktool(self, apktool_path: str) -> None:
        """Extract APK using apktool."""
        self.extracted_dir = self.out_dir / "apktool_out"

        cmd = [
            apktool_path,
            "d",  # decode
            "-f",  # force overwrite
            "-o",
            str(self.extracted_dir),
            str(self.apk_path),
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=300,
        )

        if result.returncode != 0:
            raise RuntimeError(f"apktool failed: {result.stderr}")

    def _decompile_jadx(self, jadx_path: str) -> None:
        """Decompile APK using jadx."""
        self.decompiled_dir = self.out_dir / "jadx_out"

        cmd = [
            jadx_path,
            "-d",
            str(self.decompiled_dir),
            "--deobf",  # Enable deobfuscation
            "--show-bad-code",  # Show code even if decompilation fails
            str(self.apk_path),
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=600,  # jadx can take longer
        )

        # jadx may return non-zero for warnings, check if output exists
        if not self.decompiled_dir.exists():
            raise RuntimeError(f"jadx failed: {result.stderr}")

    def _parse_manifest(self) -> dict:
        """Parse AndroidManifest.xml for package info and components."""
        info = {
            "activities": [],
            "services": [],
            "receivers": [],
            "providers": [],
            "permissions": [],
            "exported": [],
        }

        manifest_path = self.extracted_dir / "AndroidManifest.xml"
        if not manifest_path.exists():
            return info

        try:
            tree = ET.parse(manifest_path)
            root = tree.getroot()

            # Android namespace
            ns = {"android": "http://schemas.android.com/apk/res/android"}

            # Package info
            info["package"] = root.get("package")
            info["version_code"] = root.get(f"{{{ns['android']}}}versionCode")
            info["version_name"] = root.get(f"{{{ns['android']}}}versionName")

            # SDK versions
            uses_sdk = root.find("uses-sdk")
            if uses_sdk is not None:
                info["min_sdk"] = uses_sdk.get(f"{{{ns['android']}}}minSdkVersion")
                info["target_sdk"] = uses_sdk.get(f"{{{ns['android']}}}targetSdkVersion")

            # Permissions
            for perm in root.findall("uses-permission"):
                perm_name = perm.get(f"{{{ns['android']}}}name")
                if perm_name:
                    info["permissions"].append(perm_name)

            # Application components
            app = root.find("application")
            if app is not None:
                # Activities
                for activity in app.findall("activity"):
                    name = activity.get(f"{{{ns['android']}}}name")
                    exported = activity.get(f"{{{ns['android']}}}exported")
                    if name:
                        info["activities"].append(name)
                        if exported == "true":
                            info["exported"].append({"type": "activity", "name": name})
                        # Check for intent filters (implicit export)
                        if activity.find("intent-filter") is not None and exported != "false":
                            if {"type": "activity", "name": name} not in info["exported"]:
                                info["exported"].append({"type": "activity", "name": name, "implicit": True})

                # Also check activity-alias
                for alias in app.findall("activity-alias"):
                    name = alias.get(f"{{{ns['android']}}}name")
                    if name:
                        info["activities"].append(name)

                # Services
                for service in app.findall("service"):
                    name = service.get(f"{{{ns['android']}}}name")
                    exported = service.get(f"{{{ns['android']}}}exported")
                    if name:
                        info["services"].append(name)
                        if exported == "true":
                            info["exported"].append({"type": "service", "name": name})

                # Receivers
                for receiver in app.findall("receiver"):
                    name = receiver.get(f"{{{ns['android']}}}name")
                    exported = receiver.get(f"{{{ns['android']}}}exported")
                    if name:
                        info["receivers"].append(name)
                        if exported == "true":
                            info["exported"].append({"type": "receiver", "name": name})

                # Providers
                for provider in app.findall("provider"):
                    name = provider.get(f"{{{ns['android']}}}name")
                    exported = provider.get(f"{{{ns['android']}}}exported")
                    if name:
                        info["providers"].append(name)
                        if exported == "true":
                            info["exported"].append({"type": "provider", "name": name})

        except ET.ParseError as e:
            info["parse_error"] = str(e)

        return info

    def _generate_file_tree(self) -> tuple[list, int]:
        """Generate a summary of the extracted file tree."""
        tree = []
        total_files = 0

        if not self.extracted_dir or not self.extracted_dir.exists():
            return tree, 0

        # Walk and categorize files
        categories = {
            "smali": [],
            "resources": [],
            "assets": [],
            "libs": [],
            "other": [],
        }

        for root, dirs, files in os.walk(self.extracted_dir):
            rel_root = Path(root).relative_to(self.extracted_dir)

            for f in files:
                total_files += 1
                rel_path = str(rel_root / f)

                if rel_path.startswith("smali"):
                    categories["smali"].append(rel_path)
                elif rel_path.startswith("res"):
                    categories["resources"].append(rel_path)
                elif rel_path.startswith("assets"):
                    categories["assets"].append(rel_path)
                elif rel_path.startswith("lib"):
                    categories["libs"].append(rel_path)
                else:
                    categories["other"].append(rel_path)

        # Build summary (don't include every file, just counts and samples)
        for category, files in categories.items():
            if files:
                entry = {
                    "category": category,
                    "count": len(files),
                    "samples": files[:10],  # First 10 as samples
                }
                tree.append(entry)

        return tree, total_files

    def _extract_strings(self) -> list:
        """Extract interesting strings from the APK."""
        strings = []
        seen = set()

        # Patterns for interesting strings
        patterns = [
            (r'https?://[^\s"\'<>]{5,}', "url"),
            (r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', "email"),
            (r'(?i)(api[_-]?key|secret|token|password)\s*[=:]\s*["\'][^"\']+["\']', "credential"),
            (r'/[a-zA-Z0-9._/-]{5,}', "path"),
            (r'(?i)(firebase|amazonaws|azure|googleapis)', "cloud_service"),
        ]

        # Search in decompiled Java sources
        if self.decompiled_dir and self.decompiled_dir.exists():
            sources_dir = self.decompiled_dir / "sources"
            if sources_dir.exists():
                for java_file in sources_dir.rglob("*.java"):
                    try:
                        content = java_file.read_text(errors="ignore")
                        for pattern, stype in patterns:
                            for match in re.finditer(pattern, content):
                                val = match.group(0)
                                if val not in seen and len(val) < 500:
                                    seen.add(val)
                                    strings.append({
                                        "type": stype,
                                        "value": val,
                                        "file": str(java_file.relative_to(self.decompiled_dir)),
                                    })
                    except Exception:
                        pass

        # Also check strings.xml
        if self.extracted_dir:
            strings_xml = self.extracted_dir / "res" / "values" / "strings.xml"
            if strings_xml.exists():
                try:
                    tree = ET.parse(strings_xml)
                    for string_elem in tree.findall(".//string"):
                        name = string_elem.get("name", "")
                        value = string_elem.text or ""
                        if value and len(value) > 3:
                            for pattern, stype in patterns:
                                if re.search(pattern, value):
                                    key = f"{name}:{value}"
                                    if key not in seen:
                                        seen.add(key)
                                        strings.append({
                                            "type": stype,
                                            "value": value,
                                            "name": name,
                                            "file": "res/values/strings.xml",
                                        })
                except Exception:
                    pass

        return strings[:500]  # Limit to 500 strings

    def _list_resources(self) -> list:
        """List resources in the APK."""
        resources = []

        if not self.extracted_dir:
            return resources

        res_dir = self.extracted_dir / "res"
        if not res_dir.exists():
            return resources

        # Categorize resources
        for subdir in res_dir.iterdir():
            if subdir.is_dir():
                files = list(subdir.iterdir())
                resources.append({
                    "type": subdir.name,
                    "count": len(files),
                    "samples": [f.name for f in files[:5]],
                })

        # Assets
        assets_dir = self.extracted_dir / "assets"
        if assets_dir.exists():
            asset_files = []
            for f in assets_dir.rglob("*"):
                if f.is_file():
                    asset_files.append(str(f.relative_to(assets_dir)))
            if asset_files:
                resources.append({
                    "type": "assets",
                    "count": len(asset_files),
                    "samples": asset_files[:10],
                })

        # Native libs
        lib_dir = self.extracted_dir / "lib"
        if lib_dir.exists():
            for arch_dir in lib_dir.iterdir():
                if arch_dir.is_dir():
                    libs = list(arch_dir.glob("*.so"))
                    if libs:
                        resources.append({
                            "type": f"native_libs_{arch_dir.name}",
                            "count": len(libs),
                            "samples": [lib.name for lib in libs[:10]],
                        })

        return resources

    def _scan_suspicious(self) -> list:
        """Scan for suspicious patterns in decompiled code."""
        hits = []

        if not self.decompiled_dir:
            return hits

        sources_dir = self.decompiled_dir / "sources"
        if not sources_dir.exists():
            return hits

        # Track unique hits
        seen_hits = set()

        for java_file in sources_dir.rglob("*.java"):
            try:
                content = java_file.read_text(errors="ignore")
                rel_path = str(java_file.relative_to(self.decompiled_dir))

                for category, patterns in SUSPICIOUS_PATTERNS.items():
                    for pattern in patterns:
                        for match in re.finditer(pattern, content):
                            # Get context (line containing match)
                            start = content.rfind("\n", 0, match.start()) + 1
                            end = content.find("\n", match.end())
                            if end == -1:
                                end = len(content)
                            line = content[start:end].strip()

                            # Create unique key
                            hit_key = f"{category}:{match.group(0)[:100]}"
                            if hit_key in seen_hits:
                                continue
                            seen_hits.add(hit_key)

                            hits.append({
                                "category": category,
                                "pattern": pattern[:50],
                                "match": match.group(0)[:200],
                                "file": rel_path,
                                "context": line[:300],
                            })

                            # Limit hits per file
                            if len(hits) > 1000:
                                return hits

            except Exception:
                pass

        return hits

    def _count_classes(self) -> int:
        """Count total Java classes in decompiled output."""
        count = 0

        if self.decompiled_dir:
            sources_dir = self.decompiled_dir / "sources"
            if sources_dir.exists():
                count = len(list(sources_dir.rglob("*.java")))

        return count

    def _save_artifacts(self, result: APKAnalysisResult) -> None:
        """Save analysis artifacts to the output directory."""
        # 1. File tree summary
        tree_file = self.out_dir / "file_tree.txt"
        with open(tree_file, "w") as f:
            f.write(f"# APK File Tree Summary\n")
            f.write(f"# Total files: {result.total_files}\n\n")
            for entry in result.file_tree:
                f.write(f"\n## {entry['category']} ({entry['count']} files)\n")
                for sample in entry["samples"]:
                    f.write(f"  {sample}\n")
                if entry["count"] > len(entry["samples"]):
                    f.write(f"  ... and {entry['count'] - len(entry['samples'])} more\n")

        # 2. Strings scan
        strings_file = self.out_dir / "strings.json"
        with open(strings_file, "w") as f:
            json.dump(result.strings, f, indent=2)

        # 3. Resources list
        resources_file = self.out_dir / "resources.json"
        with open(resources_file, "w") as f:
            json.dump(result.resources, f, indent=2)

        # 4. Package/entry points
        manifest_file = self.out_dir / "manifest_info.json"
        manifest_info = {
            "package_name": result.package_name,
            "version_name": result.version_name,
            "version_code": result.version_code,
            "min_sdk": result.min_sdk,
            "target_sdk": result.target_sdk,
            "activities": result.activities,
            "services": result.services,
            "receivers": result.receivers,
            "providers": result.providers,
            "permissions": result.permissions,
            "exported_components": result.exported_components,
        }
        with open(manifest_file, "w") as f:
            json.dump(manifest_info, f, indent=2)

        # 5. Suspicious hits
        suspicious_file = self.out_dir / "suspicious_hits.json"
        with open(suspicious_file, "w") as f:
            json.dump(result.suspicious_hits, f, indent=2)

        # 6. JSON summary
        summary_file = self.out_dir / "summary.json"
        summary = {
            "run_id": result.run_id,
            "apk_path": result.apk_path,
            "success": result.success,
            "error": result.error,
            "elapsed_seconds": result.elapsed_seconds,
            "package": {
                "name": result.package_name,
                "version_name": result.version_name,
                "version_code": result.version_code,
                "min_sdk": result.min_sdk,
                "target_sdk": result.target_sdk,
            },
            "stats": {
                "total_files": result.total_files,
                "total_classes": result.total_classes,
                "activities": len(result.activities),
                "services": len(result.services),
                "receivers": len(result.receivers),
                "providers": len(result.providers),
                "permissions": len(result.permissions),
                "exported_components": len(result.exported_components),
                "strings_found": len(result.strings),
                "suspicious_hits": len(result.suspicious_hits),
            },
            "top_suspicious": self._summarize_suspicious(result.suspicious_hits),
            "artifacts": {
                "file_tree": "file_tree.txt",
                "strings": "strings.json",
                "resources": "resources.json",
                "manifest_info": "manifest_info.json",
                "suspicious_hits": "suspicious_hits.json",
                "apktool_output": "apktool_out/",
                "jadx_output": "jadx_out/",
            },
        }
        with open(summary_file, "w") as f:
            json.dump(summary, f, indent=2)

    def _summarize_suspicious(self, hits: list) -> dict:
        """Summarize suspicious hits by category."""
        summary = {}
        for hit in hits:
            cat = hit.get("category", "unknown")
            if cat not in summary:
                summary[cat] = 0
            summary[cat] += 1
        return summary

    def _get_tool_versions(self) -> dict:
        """Get versions of tools used."""
        versions = {}

        try:
            result = subprocess.run(
                ["apktool", "--version"],
                capture_output=True, text=True, timeout=10
            )
            versions["apktool"] = result.stdout.strip() or "unknown"
        except Exception:
            versions["apktool"] = "unknown"

        try:
            result = subprocess.run(
                ["jadx", "--version"],
                capture_output=True, text=True, timeout=10
            )
            versions["jadx"] = result.stdout.strip() or "unknown"
        except Exception:
            versions["jadx"] = "unknown"

        return versions

    def _get_git_commit(self) -> Optional[str]:
        """Get current git commit hash if in a repo."""
        try:
            result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                capture_output=True, text=True, timeout=10,
                cwd=Path(__file__).parent.parent.parent
            )
            if result.returncode == 0:
                return result.stdout.strip()[:8]
        except Exception:
            pass
        return None

    def solve(
        self,
        flag_regex: Optional[str] = None,
        max_decode_attempts: int = 100,
    ) -> "SolverResult":
        """
        Run the CTF solver on extracted APK artifacts.

        Must be called after analyze() has completed successfully.

        Args:
            flag_regex: Custom regex for flag detection
            max_decode_attempts: Max tokens to try decoding

        Returns:
            SolverResult with flags and evidence
        """
        from .solver import APKSolver, SolverResult

        if not self.extracted_dir or not self.extracted_dir.exists():
            raise RuntimeError("APK not extracted. Run analyze() first.")

        solver = APKSolver(
            out_dir=self.out_dir,
            flag_regex=flag_regex,
            max_decode_attempts=max_decode_attempts,
        )

        return solver.solve()

    def save_solve_results(
        self,
        analysis_result: APKAnalysisResult,
        solver_result: "SolverResult",
    ) -> None:
        """
        Save solver results to disk.

        Creates:
        - summary.json (with flags and evidence)
        - run.json (metadata)
        - transcript.txt (created by solver)
        """
        from .solver import SolverResult
        import time

        # 1. Create run.json with metadata
        run_file = self.out_dir / "run.json"
        run_data = {
            "run_id": self.run_id,
            "apk_path": str(self.apk_path),
            "apk_name": self.apk_path.name,
            "mode": "solve",
            "started_at": datetime.now().isoformat(),
            "tool_versions": self._get_tool_versions(),
            "git_commit": self._get_git_commit(),
            "config": {
                "max_decode_attempts": 100,
                "flag_patterns": ["picoCTF\\{[^}]+\\}", "flag\\{[^}]+\\}", "CTF\\{[^}]+\\}"],
            },
            "timings": {
                "extraction_seconds": analysis_result.elapsed_seconds,
                "solver_seconds": solver_result.elapsed_seconds,
                "total_seconds": analysis_result.elapsed_seconds + solver_result.elapsed_seconds,
            },
        }
        with open(run_file, "w") as f:
            json.dump(run_data, f, indent=2)

        # 2. Create/update summary.json with solver results
        summary_file = self.out_dir / "summary.json"

        # Format flags with evidence
        flags_data = []
        for flag_ev in solver_result.flags:
            flags_data.append({
                "flag": flag_ev.flag,
                "evidence": {
                    "file": flag_ev.file,
                    "line": flag_ev.line,
                    "extract": flag_ev.extract,
                    "method": flag_ev.method,
                    "input_token": flag_ev.input_token[:100] + "..." if len(flag_ev.input_token) > 100 else flag_ev.input_token,
                }
            })

        # Format top hits (patterns found but not decoded to flags)
        top_hits = []
        for hit in solver_result.hits[:20]:
            top_hits.append({
                "file": hit.file,
                "line": hit.line,
                "pattern_type": hit.pattern_type,
                "match": hit.match,
            })

        # Format decode attempts
        decode_log = []
        for attempt in solver_result.decode_attempts[:50]:
            decode_log.append({
                "token": attempt.token,
                "method": attempt.method,
                "success": attempt.success,
                "result": attempt.result[:50] if attempt.result else None,
                "error": attempt.error,
            })

        summary = {
            "run_id": self.run_id,
            "apk_path": str(self.apk_path),
            "mode": "solve",
            "success": solver_result.success,
            "flags": flags_data,
            "elapsed_seconds": analysis_result.elapsed_seconds + solver_result.elapsed_seconds,
            "errors": [analysis_result.error] if analysis_result.error else [],
            "stop_reason": solver_result.stop_reason,
            "package": {
                "name": analysis_result.package_name,
                "version_name": analysis_result.version_name,
                "version_code": analysis_result.version_code,
            },
            "stats": {
                "total_files": analysis_result.total_files,
                "total_classes": analysis_result.total_classes,
                "pattern_hits": len(solver_result.hits),
                "decode_attempts": len(solver_result.decode_attempts),
            },
            "top_hits": top_hits,
            "decode_attempts": decode_log,
            "artifacts": {
                "transcript": "transcript.txt",
                "run_metadata": "run.json",
                "file_tree": "file_tree.txt",
                "strings": "strings.json",
                "resources": "resources.json",
                "manifest_info": "manifest_info.json",
                "suspicious_hits": "suspicious_hits.json",
                "apktool_output": "apktool_out/",
                "jadx_output": "jadx_out/",
            },
        }

        with open(summary_file, "w") as f:
            json.dump(summary, f, indent=2)
